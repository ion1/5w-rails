\documentclass{article}
\usepackage[english,finnish]{babel}
\usepackage[utf8]{inputenc}

\usepackage{float}
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[colorlinks=true]{hyperref}
\usepackage{xcolor}

\usepackage{texments}
\usestyle{default}

\renewcommand{\familydefault}{\sfdefault}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}

\newsavebox{\myfigurebox}
\makeatletter
\newenvironment{myfigure}[1][tbp]{
  \begin{figure}[#1]
    \centering
    \begin{lrbox}{\myfigurebox}
      \begin{minipage}{\textwidth}
}{
      \end{minipage}
    \end{lrbox}
    \colorbox{blue!4}{\usebox{\myfigurebox}}
  \end{figure}
}
\makeatother

\newcommand{\myref}[2]{\hyperref[#2]{#1~\ref*{#2}}}

\newcommand{\pdfforeignlanguage}[2]{\texorpdfstring{\foreignlanguage{#1}{#2}}{#2}}

\newcommand{\eng}[1]{\pdfforeignlanguage{english}{#1}}
\newenvironment{english}{\begin{otherlanguage}{english}}{\end{otherlanguage}}

\newcommand{\fin}[1]{\pdfforeignlanguage{finnish}{#1}}
\newenvironment{finnish}{\begin{otherlanguage}{finnish}}{\end{otherlanguage}}

\title{\eng{5w Ruby on Rails workshop}}
\author{Johan Kiviniemi}

\begin{document}
\maketitle

\begin{abstract}
Jotain dokumentaationtynkää 5w:n\footnote{\url{http://5w.fi/}}, Tampereen
hackerspacen, Rails-opiskeluprojektista.
\end{abstract}

\tableofcontents

\section{Sessio 2010-03-01}

\subsection{Railsin asentaminen}

\begin{samepage}
Tarkoituksena on käyttää Railsin
versiota~3\footnote{\url{http://guides.rails.info/3\_0\_release\_notes.html}},
joka on vielä beta-vaiheessa.

Asenna ensin Ruby~1.9.1 järjestelmään. Debianissa ja Ubuntussa tarvittavat
paketit tulevat ri1.9.1-paketin riippuvuuksina.

\begin{pygmented}{console}
% sudo apt-get install ri1.9.1
\end{pygmented}

(Huom. \% merkitsee shellin komentokehotetta. Bash-käyttäjillä se on \$.)
\end{samepage}

\begin{samepage}
Asenna uusin RubyGems-versio omaan kotihakemistoosi. Kirjoitushetkellä
Debianissa ja Ubuntussa oleva RubyGems-versio on liian vanha.

\begin{pygmented}{console}
% mkdir -p /tmp/src/rubygems
% cd /tmp/src/rubygems

(http://rubygems.org/pages/download)
% wget http://production.cf.rubygems.org/rubygems/rubygems-1.3.6.tgz

% tar zxf rubygems-1.3.6.tgz
% cd rubygems-1.3.6

% export GEM_HOME="$HOME/.gem/ruby/1.9.1"
% export PATH="$PATH:$GEM_HOME/bin:$HOME/.gem/rubygems/bin"
% export RUBYLIB="$HOME/.gem/rubygems/lib"

% ruby1.9.1 setup.rb --prefix="$HOME/.gem/rubygems"
\end{pygmented}
\end{samepage}

Lisää myös nuo kolme export-komentoa shellisi käynnistystiedostoon (esim.
\textasciitilde/.bashrc tai \textasciitilde/.zshrc), jotta RubyGems-asennus
toimii jatkossakin käynnistämissäsi shelleissä.

\begin{samepage}
Seuraavaksi asenna Rails~3.

\begin{pygmented}{console}
% sudo apt-get install ruby1.9.1-dev libsqlite3-dev libopenssl-ruby1.9.1
% gem1.9.1 install rails --pre
\end{pygmented}
\end{samepage}

\subsection{Uuden projektin luominen}

\begin{samepage}
Seuraavat komennot luovat \textasciitilde/src-hakemiston alle
t5w.fi-hakemiston, joka sisältää tyhjän Rails-projektin puun.

Tulemme käyttämään RSpec-kirjastoa yksikkötestaukseen TestUnitin sijaan, ja
jQuery-JavaScript-kirjastoa Prototypen sijaan. Lisää niistä myöhemmin.

\begin{pygmented}{console}
% cd ~/src
(or wherever you want to create the project)

% rails t5w.fi --skip-testunit --skip-prototype
% cd t5w.fi
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna Gemfile-tiedoston listaamat projektin riippuvuudet.

\begin{pygmented}{console}
% bundle install
\end{pygmented}
\end{samepage}

Luomassamme projektissa on tiedosto config/database.yml, joka sisältää
asetukset tietokantaan yhdistämiseen. Emme halua sen päätyvän
versionhallintaan, koska tietokanta-asetukset tulevat olemaan mm.
kehitysympäristössä erilaiset kuin tuotantopalvelimella.

\begin{samepage}
Kopioi config/database.yml tiedostoon config/database.yml.example, ja varmista,
että vain jälkimmäinen päätyy versionhallintaan.

\begin{pygmented}{console}
% cp config/database.yml{,.example}
% echo config/database.yml >>.gitignore
\end{pygmented}
\end{samepage}

Rails ylläpitää tiedostossa \texttt{db/schema.rb} kuvausta tietokannan
skeemasta. Sovelluksen päivityksen yhteydessä Railsin migrations-toiminto
hoitaa olemassa olevan tietokannan päivittämisen uuden koodin kanssa
yhteensopivaksi, mutta uudet tietokannat alustetaan suoraan kyseisen tiedoston
perusteella.

\begin{samepage}
Jotta \texttt{db/schema.rb}:n lisääminen versionhallintaan ei pääse myöhemmin
unohtumaan, luodaan sen ensimmäinen (tyhjä) versio heti seuraavaa committia
varten Rake-komennolla \texttt{db:migrate}.

\begin{pygmented}{console}
% rake db:migrate
\end{pygmented}
\end{samepage}

\subsection{Versionhallinnan alustaminen}

Jos olet käyttämässä Git-versionhallintaa ensimmäistä kertaa, katso
\myref{kuva}{fig:git-initial-config}.

\begin{myfigure}
\caption{Perusasetuksien teko ensimmäisellä Git-käyttökerralla}
\label{fig:git-initial-config}

\begin{pygmented}{console}
% git config --global user.name 'Etunimi Sukunimi'
% git config --global user.email 'user@example.net'
% for n in branch diff grep interactive status ui; do
>   git config --global "color.$n" auto
> done
\end{pygmented}
\end{myfigure}

\begin{samepage}
Alusta Git nykyiseen hakemistoon, lisää sisältö seuraavaa committia varten ja
luo ensimmäinen commit.

\begin{pygmented}{console}
% git init
% git add .
% git commit -m 'Initial import'
\end{pygmented}
\end{samepage}

\subsection{Testaus}

Testaaminen on oleellinen osa sovelluskehitystä. Jos jättäisimme testaamisen
väliin, meillä ei olisi mitään takeita siitä, että kukin tuotantoon asentamamme
ohjelmapäivitys toimii täysin oikein.

Pieniä ja isompia bugeja livahtaa koodiin aina, ja hyvin tehty testisarja
(engl. \eng{test suite}) löytää ne nopeasti.

Käytän tässä dokumentissa termiä integraatiotestaus (engl. \eng{integration
testing}) sovelluksen käyttäjälle näkyvän toiminnallisuuden kokonaisvaltaisesta
testaamisesta, ja termiä yksikkötestaus (engl. \eng{unit testing}) sovelluksen
sisäisten rajapintojen testaamisesta.

Testit on mahdollista kirjoittaa ennen tai jälkeen varsinaisen toteutuksen
ohjelmoimista. Testien kirjoittamisesta etukäteen on joitakin
etuja\footnote{\eng{Test Driven Development; Behavior Driven Development;
\url{http://en.wikipedia.org/wiki/Test-driven\_development##Benefits}}}:

\begin{itemize}
\item
Testisarjasta saadaan varmemmin kattava, mikäli pitäydytään toimintatavassa,
jossa ei kirjoiteta implementaatiokoodia ennen testien olemassaoloa.

\item
Tämä toimintatapa toimii apuvälineenä tulevan toteutuksen rajapinnan tai
käyttöliittymän suunnittelussa. Testejä luodessa kirjoitetaan koodia, joka
käyttää kuvitteellista, mahdollisimman miellyttävää rajapintaa.

Toteutusta tehdessä optimaalinen rajapinta tai käyttöliittymän toimintatapa on
näin jo hahmottunut.

\item
Hyvin tehdyt testit toimivat käytännön esimerkkeinä rajapintojen käytöstä,
täydentäen dokumentaatiota.

\item
Testisarja kertoo kunkin speksatun asian suhteen, mistä aloittaa, mitä tehdä
seuraavaksi ja milloin speksi on implementoitu.
\end{itemize}

\subsection{Testauskirjastojen asennus}

Käytämme RSpec\footnote{\url{http://rspec.info/}}-kirjastoa yksikkötestaukseen
ja Cucumber\footnote{\url{http://cukes.info/}}-kirjastoa
integraatiotestaukseen, hyödyntäen
Capybara\footnote{\url{http://github.com/jnicklas/capybara\#readme}}-selainsimulaattoria.

\begin{samepage}
Avaa Gemfile-tiedosto editoriin ja lisää siihen seuraavat rivit:

\begin{pygmented}{ruby}
# Use RSpec for unit testing.
group :test do
  gem 'rspec', '>= 2.0.0.a'
  gem 'rspec-rails', '>= 2.0.0.a'
end
\end{pygmented}
\end{samepage}

\begin{samepage}
Aja seuraava komento, jotta kyseiset gemit asentuvat.

\begin{pygmented}{console}
% bundle install
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna RSpecin projektikohtaiset tiedostot, jotta testaus sillä onnistuu
jatkossa.

\begin{pygmented}{console}
% script/rails generate rspec:install
% git add .
% git commit -m 'Add RSpec'
\end{pygmented}
\end{samepage}

\begin{samepage}
Muokkaa jälleen Gemfile-tiedostoa lisäten seuraavat rivit:

\begin{pygmented}{ruby}
# Use Cucumber with Capybara for integration testing.
group :test do
  gem 'capybara'
  # The slimmed down version of test-unit in Ruby 1.9.1 isn't enough for
  # Cucumber.
  gem 'test-unit'
  gem 'cucumber'
  gem 'cucumber-rails', :git => 'git://github.com/ion1/cucumber-rails.git'
end
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna kyseiset gemit.

\begin{pygmented}{console}
% bundle install
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna Cucumberin projektikohtaiset tiedostot.

\begin{pygmented}{console}
% script/rails generate cucumber:skeleton --capybara --rspec
...
       force  config/database.yml
...

(config/database.yml was modified, update example)
% cp config/database.yml{,.example}

% git add .
% git commit -m 'Add Cucumber'
\end{pygmented}
\end{samepage}

\subsection{Ensimmäinen integraatiotesti: \eng{Manage projects}}

Luo editorissa tiedosto \texttt{features/manage\_projects.feature}
(\myref{kuva}{fig:manage-projects-feature}).

\begin{myfigure}
\caption{\texttt{features/manage\_projects.feature}}
\label{fig:manage-projects-feature}

\includecode{include/manage_projects-00.feature}
\end{myfigure}

Esimerkin alussa oleva ''@wip'' (''\eng{work in progress}'') on tagi, jonka
perusteella voidaan rajata työn alla olevat speksit ajettavaksi kerralla.

\eng{Feature}-lohko alussa noudattaa tiettyä
formaattia\footnote{\url{http://wiki.github.com/aslakhellesoy/cucumber/gherkin}},
mutta on pelkkää dokumentaatiota. Varsinaiset ajettavat testit ovat
\eng{Scenario}-lohkoissa.

Ensimmäinen skenaario testaa projektin onnistuneen lisäyksen käyttäjän
näkökulmasta.

Seuraava skenaario (huom. ''\eng{Scenario \emph{Outline}}'') suoritetaan sen
sisältämän \eng{Examples}-taulukon mukaisesti neljä kertaa, täydentäen
kulmasulkeiden sisältämien kenttien tilalle arvot taulukosta.  Kyseinen
skenaario varmistaa virheenkäsittelyn toiminnan jättäen kullakin kerralla yhden
kentistä tyhjäksi (täyttäen muut validilla arvolla ''x'').

Viimeinen skenaario on samankaltainen ensimmäisen kanssa, mutta se varmistaa,
että lisätty projekti ilmestyy myös projektilistaan.

Risuaidalla alkavat rivit ovat kommentteja: \eng{Who}-kenttien testaus
toteutetaan myöhemmin, kun sovellukseen lisätään tuki käyttäjätunnuksille.

Cucumber-Railsin mukana tulee ohjelmakoodia, jonka perusteella \eng{Cucumber}
tietää, mitä tehdä, kun speksissä lukee esim. ''\eng{When I press \dots''} tai
''\eng{Then I should see \dots}''.

Tämän speksin ainoa testi, jonka toteuttavan koodin joudumme toteuttamaan itse,
on ''\eng{Then I should see a timestamp no older/newer than \dots}''. Se
demonstroidaan ajallaan.

\begin{samepage}
Tee myös tästä muutoksesta commit.

\begin{pygmented}{console}
% git add features
% git commit -m 'Add initial manage_projects feature'
\end{pygmented}
\end{samepage}

\section{Sessio 2010-03-09}

\subsection{Cucumber-testien ajo}

\begin{samepage}
Aja wip-tagilla merkityt testit Rake-komennolla \texttt{cucumber:wip}.
Ensimmäinen ilmoitus epäonnistuneesta testistä kertoo, mitä tulee toteuttaa
seuraavaksi.

\begin{pygmented}{console}
% rake cucumber:wip
...
  Scenario: Add a new project                           # features/manage_projects.feature:7
    Given I am on the New Project page                  # features/step_definitions/web_steps.rb:14
      Can't find mapping from "the New Project page" to a path.
      Now, go and add a mapping in features/support/paths.rb (RuntimeError)
\end{pygmented}
\end{samepage}

Koska projects-koodia ei ole, ei ole New Project -sivuakaan. Seuraavana on siis
sen toteuttaminen. Pohjustan ensin joitakin Railsin konsepteja.

\subsection[MVC, model--view--controller-arkkitehtuuri]{MVC,
model--view--controller-arkkitehtuuri\footnote{\url{http://en.wikipedia.org/wiki/Model-view-controller}}}

On hyvä erotella sovellus riittävän pieniin, irrallisiin osiin, joista kutakin
voidaan kehittää, testata ja ylläpitää erikseen. Rails-projektit käyttävät
suosittua MVC-arkkitehtuuria.

\begin{description}
\item[Model (malli)]
Sovelluksen käyttämän datan (esim. tietokanta tai sellaisen tapaan käytettävä
web-rajapinta) kuvaus ja sovelluksen logiikka.

\item[View (näkymä)]
Mallien esitysmuoto. Yksi näkymä saattaa esittää useampaa mallia (esim.
uutisartikkelin web-sivu, joka listaa artikkelin kommentit), ja yhdelle
mallille voi olla useampi näkymä (esim. uusimmat artikkelit listaava web-sivu
ja uusimpien artikkeleiden Atom-syöte).

\item[Controller (ohjain)]
Ohjain käsittelee käyttäjältä tulevan syötteen ja vastaa siihen kommunikoiden
mallin ja näkymän kanssa sen perusteella.
\end{description}

\subsection[REST, Representational State Transfer]{REST, Representational State
Transfer\footnote{\url{http://en.wikipedia.org/wiki/Representational\_State\_Transfer}}}

Käsittelen Rails-projektin kannalta oleellisimmat REST-konseptin
yksityiskohdat.

\begin{samepage}
Kiinnitä huomio seuraaviin esimerkkeihin HTTP-pyynnöistä.

\begin{tabular}{rl}
Metodi      & Polku                      \\
\hline
\verb!POST! & \verb!/projects/create!    \\
\verb!GET!  & \verb!/projects/42!        \\
\verb!POST! & \verb!/projects/update/42! \\
\verb!POST! & \verb!/projects/delete/42! \\
\end{tabular}
\end{samepage}

Ensinnäkin on havaittavissa toistoa: pyynnöissä on verbejä (\eng{create,
update, delete}), mutta jokaiseen HTTP-pyyntöön kuuluu verbi metodin muodossa
joka tapauksessa.

\begin{samepage}
Lisäksi jos hyödyntäisimme HTTP-verbejä kyseisissä pyynnöissä, samaa resurssia
käsittelevien pyyntöjen polut muuttuisivat samoiksi; tässä voi havaita tiettyä
eleganssia.

\begin{tabular}{rl}
Metodi        & Polku               \\
\hline
\verb!POST!   & \verb!/projects!    \\
\verb!GET!    & \verb!/projects/42! \\
\verb!PUT!    & \verb!/projects/42! \\
\verb!DELETE! & \verb!/projects/42! \\
\end{tabular}
\end{samepage}

Kyseisistä neljästä verbistä käytetään termiä \eng{CRUD -- create, read,
update,
delete}\footnote{\url{http://en.wikipedia.org/wiki/Create,\_read,\_update\_and\_delete}}
(\myref{kuva}{fig:crud}).

\begin{myfigure}
\centering
\caption{CRUD-verbit eräissä syntakseissa}
\label{fig:crud}

\begin{tabular}{ccc}
       & SQL    & HTTP   \\
\hline
Create & INSERT & POST   \\
Read   & SELECT & GET    \\
Update & UPDATE & PUT    \\
Delete & DELETE & DELETE \\
\end{tabular}
\end{myfigure}

\begin{samepage}
Mitä käytännön hyötyä on saavutettu? Ei oikeastaan vielä mitään merkittävää.
Hyötyjä havainnollistetaan seuraavalla esimerkillä.

\begin{tabular}{rll}
Metodi      & Polku                           & Sisältö (\eng{body}) \\
\hline
\verb!POST! & \verb!/projects/42/add_user!    & \verb!user_id=5!     \\
\verb!POST! & \verb!/projects/42/delete_user! & \verb!user_id=5!     \\
\hline
\verb!POST! & \verb!/users/5/join_project!    & \verb!project_id=42! \\
\verb!POST! & \verb!/users/5/leave_project!   & \verb!project_id=42! \\
\end{tabular}
\end{samepage}

Kumpaan ohjaimeen käyttäjän liittäminen projektiin kuuluu -- projektit vai
käyttäjät?

Pitäisikö projekti- vai käyttäjämallin varmistaa, sallitaanko tietyn käyttäjän
poistaminen projektista?

Jos haluttaisiin talteen kunkin jäsenen liittymisajankohta kuhunkin projektiin
ja käyttäjän halutessaan syöttämä roolinsa kussakin projektissa, minkä mallin
tulisi pitää tästä kaikesta kirjaa?

Tämä kaikki muuttuu selkeämmäksi, kun annamme projektien ja käyttäjien
väliselle relaatiolle nimen: \emph{\eng{project memberships}}.

\begin{samepage}
Nyt projektiin liittyminen ja siitä poistuminen muuttuu jäsenyyden luomiseksi
(\eng{create}) ja poistamiseksi (\eng{delete}), ja roolin muuttaminen muuttuu
jäsenyyden päivittämiseksi (\eng{update}). Pyynnöt käsittelee
\texttt{project\_memberships}-ohjain.

\begin{tabular}{rll}
Metodi        & Polku                         & Sisältö (\eng{body})                 \\
\hline
\verb!POST!   & \verb!/project_memberships!   & \verb!user_id=5&project_id=42&role=! \\
\verb!PUT!    & \verb!/project_memberships/9! & \verb!role=Moral+support!            \\
\verb!DELETE! & \verb!/project_memberships/9! &                                      \\
\end{tabular}
\end{samepage}

Rails tekee CRUD-toimintamallin noudattamisen hyvin helpoksi, kuten myöhemmin
tullaan näkemään. Samoin kuin esim. MVC:n, myös CRUDin myötä on monesti yksi
asia vähemmän mietittävänä: tietylle asialle on heti selkeä paikka ja
samankaltaiset asiat tapahtuvat konsistentimmin keskenään.

\end{document}

% vim:set et sw=2 sts=2:
