\documentclass{article}
\usepackage[english,finnish]{babel}
\usepackage[utf8]{inputenc}

\usepackage{float}
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[colorlinks=true]{hyperref}
\usepackage{xcolor}

\usepackage{texments}
\usestyle{default}

\renewcommand{\familydefault}{\sfdefault}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}

\newsavebox{\myfigurebox}
\makeatletter
\newenvironment{myfigure}[1][tbp]{
  \begin{figure}[#1]
    \centering
    \begin{lrbox}{\myfigurebox}
      \begin{minipage}{\textwidth}
}{
      \end{minipage}
    \end{lrbox}
    \colorbox{blue!4}{\usebox{\myfigurebox}}
  \end{figure}
}
\makeatother

\newcommand{\myref}[2]{\hyperref[#2]{#1~\ref*{#2}}}

\newcommand{\pdfforeignlanguage}[2]{\texorpdfstring{\foreignlanguage{#1}{#2}}{#2}}

\newcommand{\eng}[1]{\pdfforeignlanguage{english}{#1}}
\newenvironment{english}{\begin{otherlanguage}{english}}{\end{otherlanguage}}

\newcommand{\fin}[1]{\pdfforeignlanguage{finnish}{#1}}
\newenvironment{finnish}{\begin{otherlanguage}{finnish}}{\end{otherlanguage}}

\title{\eng{5w Ruby on Rails workshop}}
\author{Johan Kiviniemi}

\begin{document}
\maketitle

\begin{abstract}
Dokumentaatio 5w:n\footnote{\url{http://5w.fi/}}, Tampereen hackerspacen,
Rails-opiskeluprojektista.
\end{abstract}

\tableofcontents

\section{Sessio 2010-03-01}

\subsection{Railsin asentaminen}

\begin{samepage}
Tarkoituksena on käyttää Railsin
versiota~3\footnote{\url{http://guides.rails.info/3\_0\_release\_notes.html}},
joka on vielä beta-vaiheessa.

Asenna ensin Ruby~1.9.1 järjestelmään. Debianissa ja Ubuntussa tarvittavat
paketit tulevat ri1.9.1-paketin riippuvuuksina.

\begin{pygmented}{console}
% sudo apt-get install ri1.9.1
\end{pygmented}

(Huom. \% merkitsee shellin komentokehotetta. Bash-käyttäjillä se on \$.)
\end{samepage}

\begin{samepage}
Asenna uusin RubyGems-versio omaan kotihakemistoosi. Kirjoitushetkellä
Debianissa ja Ubuntussa oleva RubyGems-versio on liian vanha.

\begin{pygmented}{console}
% mkdir -p /tmp/src/rubygems
% cd /tmp/src/rubygems

(http://rubygems.org/pages/download)
% wget http://production.cf.rubygems.org/rubygems/rubygems-1.3.6.tgz

% tar zxf rubygems-1.3.6.tgz
% cd rubygems-1.3.6

% export GEM_HOME="$HOME/.gem/ruby/1.9.1"
% export PATH="$PATH:$GEM_HOME/bin:$HOME/.gem/rubygems/bin"
% export RUBYLIB="$HOME/.gem/rubygems/lib"

% ruby1.9.1 setup.rb --prefix="$HOME/.gem/rubygems"
\end{pygmented}
\end{samepage}

Lisää myös nuo kolme export-komentoa shellisi käynnistystiedostoon (esim.
\textasciitilde/.bashrc tai \textasciitilde/.zshrc), jotta RubyGems-asennus
toimii jatkossakin käynnistämissäsi shelleissä.

\begin{samepage}
Seuraavaksi asenna Rails~3.

\begin{pygmented}{console}
% sudo apt-get install ruby1.9.1-dev libsqlite3-dev libopenssl-ruby1.9.1
% gem1.9.1 install rails --pre
\end{pygmented}
\end{samepage}

\subsection{Uuden projektin luominen}

\begin{samepage}
Seuraavat komennot luovat \textasciitilde/src-hakemiston alle
t5w.fi-hakemiston, joka sisältää tyhjän Rails-projektin puun.

Tulemme käyttämään RSpec-kirjastoa yksikkötestaukseen TestUnitin sijaan, ja
jQuery-JavaScript-kirjastoa Prototypen sijaan. Lisää niistä myöhemmin.

\begin{pygmented}{console}
% cd ~/src
(or wherever you want to create the project)

% rails t5w.fi --skip-testunit --skip-prototype
% cd t5w.fi
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna Gemfile-tiedoston listaamat projektin riippuvuudet.

\begin{pygmented}{console}
% bundle install
\end{pygmented}
\end{samepage}

Luomassamme projektissa on tiedosto config/database.yml, joka sisältää
asetukset tietokantaan yhdistämiseen. Emme halua sen päätyvän
versionhallintaan, koska tietokanta-asetukset tulevat olemaan mm.
kehitysympäristössä erilaiset kuin tuotantopalvelimella.

\begin{samepage}
Kopioi config/database.yml tiedostoon config/database.yml.example, ja varmista,
että vain jälkimmäinen päätyy versionhallintaan.

\begin{pygmented}{console}
% cp config/database.yml{,.example}
% echo config/database.yml >>.gitignore
\end{pygmented}
\end{samepage}

Rails ylläpitää tiedostossa \texttt{db/schema.rb} kuvausta tietokannan
skeemasta. Sovelluksen päivityksen yhteydessä Railsin migrations-toiminto
hoitaa olemassa olevan tietokannan päivittämisen uuden koodin kanssa
yhteensopivaksi, mutta uudet tietokannat alustetaan suoraan kyseisen tiedoston
perusteella.

\begin{samepage}
Jotta \texttt{db/schema.rb}:n lisääminen versionhallintaan ei pääse myöhemmin
unohtumaan, luodaan sen ensimmäinen (tyhjä) versio heti seuraavaa committia
varten Rake-komennolla \texttt{db:migrate}.

\begin{pygmented}{console}
% rake db:migrate
\end{pygmented}
\end{samepage}

\subsection{Versionhallinnan alustaminen}

Jos olet käyttämässä Git-versionhallintaa ensimmäistä kertaa, katso
\myref{kuva}{fig:git-initial-config}.

\begin{myfigure}
\caption{Perusasetuksien teko ensimmäisellä Git-käyttökerralla}
\label{fig:git-initial-config}

\begin{pygmented}{console}
% git config --global user.name 'Etunimi Sukunimi'
% git config --global user.email 'user@example.net'
% for n in branch diff grep interactive status ui; do
>   git config --global "color.$n" auto
> done
\end{pygmented}
\end{myfigure}

\begin{samepage}
Alusta Git nykyiseen hakemistoon, lisää sisältö seuraavaa committia varten ja
luo ensimmäinen commit.

\begin{pygmented}{console}
% git init
% git add .
% git commit -m 'Initial import'
\end{pygmented}
\end{samepage}

\subsection{Testaus}

Testaaminen on oleellinen osa sovelluskehitystä. Jos jättäisimme testaamisen
väliin, meillä ei olisi mitään takeita siitä, että kukin tuotantoon asentamamme
ohjelmapäivitys toimii täysin oikein.

Pieniä ja isompia bugeja livahtaa koodiin aina, ja hyvin tehty testisarja
(engl. \eng{test suite}) löytää ne nopeasti.

Käytän tässä dokumentissa termiä integraatiotestaus (engl. \eng{integration
testing}) sovelluksen käyttäjälle näkyvän toiminnallisuuden kokonaisvaltaisesta
testaamisesta, ja termiä yksikkötestaus (engl. \eng{unit testing}) sovelluksen
sisäisten rajapintojen testaamisesta.

Testit on mahdollista kirjoittaa ennen tai jälkeen varsinaisen toteutuksen
ohjelmoimista. Testien kirjoittamisesta etukäteen on joitakin
etuja\footnote{\eng{Test Driven Development; Behavior Driven Development;
\url{http://en.wikipedia.org/wiki/Test-driven\_development##Benefits}}}:

\begin{itemize}
\item
Testisarjasta saadaan varmemmin kattava, mikäli pitäydytään toimintatavassa,
jossa ei kirjoiteta implementaatiokoodia ennen testien olemassaoloa.

\item
Tämä toimintatapa toimii apuvälineenä tulevan toteutuksen rajapinnan tai
käyttöliittymän suunnittelussa. Testejä luodessa kirjoitetaan koodia, joka
käyttää kuvitteellista, mahdollisimman miellyttävää rajapintaa.

Toteutusta tehdessä optimaalinen rajapinta tai käyttöliittymän toimintatapa on
näin jo hahmottunut.

\item
Hyvin tehdyt testit toimivat käytännön esimerkkeinä rajapintojen käytöstä,
täydentäen dokumentaatiota.

\item
Testisarja kertoo kunkin speksatun asian suhteen, mistä aloittaa, mitä tehdä
seuraavaksi ja milloin speksi on implementoitu.
\end{itemize}

\subsection{Testauskirjastojen asennus}

Käytämme RSpec\footnote{\url{http://rspec.info/}}-kirjastoa yksikkötestaukseen
ja Cucumber\footnote{\url{http://cukes.info/}}-kirjastoa
integraatiotestaukseen, hyödyntäen
Capybara\footnote{\url{http://github.com/jnicklas/capybara\#readme}}-selainsimulaattoria.

\begin{samepage}
Avaa Gemfile-tiedosto editoriin ja lisää siihen seuraavat rivit:

\begin{pygmented}{ruby}
# Use RSpec for unit testing.
group :test do
  gem 'rspec', '>= 2.0.0.a'
  gem 'rspec-rails', '>= 2.0.0.a'
end
\end{pygmented}
\end{samepage}

\begin{samepage}
Aja seuraava komento, jotta kyseiset gemit asentuvat.

\begin{pygmented}{console}
% bundle install
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna RSpecin projektikohtaiset tiedostot, jotta testaus sillä onnistuu
jatkossa.

\begin{pygmented}{console}
% script/rails generate rspec:install
% git add .
% git commit -m 'Add RSpec'
\end{pygmented}
\end{samepage}

\begin{samepage}
Muokkaa jälleen Gemfile-tiedostoa lisäten seuraavat rivit:

\begin{pygmented}{ruby}
# Use Cucumber with Capybara for integration testing.
group :test do
  gem 'capybara'
  # The slimmed down version of test-unit in Ruby 1.9.1 isn't enough for
  # Cucumber.
  gem 'test-unit'
  gem 'cucumber'
  gem 'cucumber-rails', :git => 'git://github.com/aslakhellesoy/cucumber-rails.git'
end
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna kyseiset gemit.

\begin{pygmented}{console}
% bundle install
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna Cucumberin projektikohtaiset tiedostot.

\begin{pygmented}{console}
% script/rails generate cucumber:skeleton --capybara --rspec
...
       force  config/database.yml
...

(config/database.yml was modified, update example)
% cp config/database.yml{,.example}

% git add .
% git commit -m 'Add Cucumber'
\end{pygmented}
\end{samepage}

\subsection{Ensimmäinen integraatiotesti: \eng{Manage projects}}

Luo editorissa tiedosto \texttt{features/manage\_projects.feature}
(\myref{kuva}{fig:manage-projects-feature}).

\begin{myfigure}
\caption{\texttt{features/manage\_projects.feature}}
\label{fig:manage-projects-feature}

\includecode{include/manage_projects-00.feature}
\end{myfigure}

Esimerkin alussa oleva ''@wip'' (''\eng{work in progress}'') on tagi, jonka
perusteella voidaan rajata työn alla olevat speksit ajettavaksi kerralla.

\eng{Feature}-lohko alussa noudattaa tiettyä
formaattia\footnote{\url{http://wiki.github.com/aslakhellesoy/cucumber/gherkin}},
mutta on pelkkää dokumentaatiota. Varsinaiset ajettavat testit ovat
\eng{Scenario}-lohkoissa.

Ensimmäinen skenaario testaa projektin onnistuneen lisäyksen käyttäjän
näkökulmasta.

Seuraava skenaario (huom. ''\eng{Scenario \emph{Outline}}'') suoritetaan sen
sisältämän \eng{Examples}-taulukon mukaisesti neljä kertaa, täydentäen
kulmasulkeiden sisältämien kenttien tilalle arvot taulukosta.  Kyseinen
skenaario varmistaa virheenkäsittelyn toiminnan jättäen kullakin kerralla yhden
kentistä tyhjäksi (täyttäen muut validilla arvolla ''x'').

Viimeinen skenaario on samankaltainen ensimmäisen kanssa, mutta se varmistaa,
että lisätty projekti ilmestyy myös projektilistaan.

Risuaidalla alkavat rivit ovat kommentteja: \eng{Who}-kenttien testaus
toteutetaan myöhemmin, kun sovellukseen lisätään tuki käyttäjätunnuksille.

Cucumber-Railsin mukana tulee ohjelmakoodia, jonka perusteella \eng{Cucumber}
tietää, mitä tehdä, kun speksissä lukee esim. ''\eng{When I press \dots''} tai
''\eng{Then I should see \dots}''.

Tämän speksin ainoa testi, jonka toteuttavan koodin joudumme toteuttamaan itse,
on ''\eng{Then I should see a timestamp no older/newer than \dots}''. Se
demonstroidaan ajallaan.

\begin{samepage}
Tee myös tästä muutoksesta commit.

\begin{pygmented}{console}
% git add features
% git commit -m 'Add initial manage_projects feature'
\end{pygmented}
\end{samepage}

\section{Sessio 2010-03-09}

\subsection{Cucumber-testien ajo}

\begin{samepage}
Aja wip-tagilla merkityt testit Rake-komennolla \texttt{cucumber:wip}.
Ensimmäinen ilmoitus epäonnistuneesta testistä kertoo, mitä tulee toteuttaa
seuraavaksi.

\begin{pygmented}{console}
% rake cucumber:wip
...
  Scenario: Add a new project                           # features/manage_projects.feature:7
    Given I am on the New Project page                  # features/step_definitions/web_steps.rb:14
      Can't find mapping from "the New Project page" to a path.
      Now, go and add a mapping in features/support/paths.rb (RuntimeError)
\end{pygmented}
\end{samepage}

Koska projects-koodia ei ole, ei ole New Project -sivuakaan. Seuraavana on siis
sen toteuttaminen. Pohjustan ensin joitakin Railsin konsepteja.

\subsection[MVC, model--view--controller-arkkitehtuuri]{MVC,
model--view--controller-arkkitehtuuri\footnote{\url{http://en.wikipedia.org/wiki/Model-view-controller}}}

On hyvä erotella sovellus riittävän pieniin, irrallisiin osiin, joista kutakin
voidaan kehittää, testata ja ylläpitää erikseen. Rails-projektit käyttävät
suosittua MVC-arkkitehtuuria.

\begin{description}
\item[Model (malli)]
Sovelluksen käyttämän datan (esim. tietokanta tai sellaisen tapaan käytettävä
web-rajapinta) kuvaus ja sovelluksen logiikka.

\item[View (näkymä)]
Mallien esitysmuoto. Yksi näkymä saattaa esittää useampaa mallia (esim.
uutisartikkelin web-sivu, joka listaa artikkelin kommentit), ja yhdelle
mallille voi olla useampi näkymä (esim. uusimmat artikkelit listaava web-sivu
ja uusimpien artikkeleiden Atom-syöte).

\item[Controller (ohjain)]
Ohjain käsittelee käyttäjältä tulevan syötteen ja vastaa siihen kommunikoiden
mallin ja näkymän kanssa sen perusteella.
\end{description}

\subsection[REST, Representational State Transfer]{REST, Representational State
Transfer\footnote{\url{http://en.wikipedia.org/wiki/Representational\_State\_Transfer}}}

Käsittelen Rails-projektin kannalta oleellisimmat REST-konseptin
yksityiskohdat.

\begin{samepage}
Kiinnitä huomio seuraaviin esimerkkeihin HTTP-pyynnöistä.

\begin{tabular}{rl}
Metodi      & Polku                      \\
\hline
\verb!POST! & \verb!/projects/create!    \\
\verb!GET!  & \verb!/projects/42!        \\
\verb!POST! & \verb!/projects/update/42! \\
\verb!POST! & \verb!/projects/delete/42! \\
\end{tabular}
\end{samepage}

Ensinnäkin on havaittavissa toistoa: pyynnöissä on verbejä (\eng{create,
update, delete}), mutta jokaiseen HTTP-pyyntöön kuuluu verbi metodin muodossa
joka tapauksessa.

\begin{samepage}
Lisäksi jos hyödyntäisimme HTTP-verbejä kyseisissä pyynnöissä, samaa resurssia
käsittelevien pyyntöjen polut muuttuisivat samoiksi; tässä voi havaita tiettyä
eleganssia.

\begin{tabular}{rl}
Metodi        & Polku               \\
\hline
\verb!POST!   & \verb!/projects!    \\
\verb!GET!    & \verb!/projects/42! \\
\verb!PUT!    & \verb!/projects/42! \\
\verb!DELETE! & \verb!/projects/42! \\
\end{tabular}
\end{samepage}

Kyseisistä neljästä verbistä käytetään termiä \eng{CRUD -- create, read,
update,
delete}\footnote{\url{http://en.wikipedia.org/wiki/Create,\_read,\_update\_and\_delete}}
(\myref{kuva}{fig:crud}).

\begin{myfigure}
\centering
\caption{CRUD-verbit eräissä syntakseissa}
\label{fig:crud}

\begin{tabular}{ccc}
       & SQL    & HTTP   \\
\hline
Create & INSERT & POST   \\
Read   & SELECT & GET    \\
Update & UPDATE & PUT    \\
Delete & DELETE & DELETE \\
\end{tabular}
\end{myfigure}

\begin{samepage}
Mitä käytännön hyötyä on saavutettu? Ei oikeastaan vielä mitään merkittävää.
Hyötyjä havainnollistetaan seuraavalla esimerkillä.

\begin{tabular}{rll}
Metodi      & Polku                           & Sisältö (\eng{body}) \\
\hline
\verb!POST! & \verb!/projects/42/add_user!    & \verb!user_id=5!     \\
\verb!POST! & \verb!/projects/42/delete_user! & \verb!user_id=5!     \\
\hline
\verb!POST! & \verb!/users/5/join_project!    & \verb!project_id=42! \\
\verb!POST! & \verb!/users/5/leave_project!   & \verb!project_id=42! \\
\end{tabular}
\end{samepage}

Kumpaan ohjaimeen käyttäjän liittäminen projektiin kuuluu -- projektit vai
käyttäjät?

Pitäisikö projekti- vai käyttäjämallin varmistaa, sallitaanko tietyn käyttäjän
poistaminen projektista?

Jos haluttaisiin talteen kunkin jäsenen liittymisajankohta kuhunkin projektiin
ja käyttäjän halutessaan syöttämä roolinsa kussakin projektissa, minkä mallin
tulisi pitää tästä kaikesta kirjaa?

Tämä kaikki muuttuu selkeämmäksi, kun annamme projektien ja käyttäjien
väliselle relaatiolle nimen: \emph{\eng{project memberships}}.

\begin{samepage}
Nyt projektiin liittyminen ja siitä poistuminen muuttuu jäsenyyden luomiseksi
(\eng{create}) ja poistamiseksi (\eng{delete}), ja roolin muuttaminen muuttuu
jäsenyyden päivittämiseksi (\eng{update}). Pyynnöt käsittelee
\texttt{project\_memberships}-ohjain.

\begin{tabular}{rll}
Metodi        & Polku                         & Sisältö (\eng{body})                 \\
\hline
\verb!POST!   & \verb!/project_memberships!   & \verb!user_id=5&project_id=42&role=! \\
\verb!PUT!    & \verb!/project_memberships/9! & \verb!role=Moral+support!            \\
\verb!DELETE! & \verb!/project_memberships/9! &                                      \\
\end{tabular}
\end{samepage}

Rails tekee CRUD-toimintamallin noudattamisen hyvin helpoksi, kuten myöhemmin
tullaan näkemään. Samoin kuin esim. MVC:n, myös CRUDin myötä on monesti yksi
asia vähemmän mietittävänä: tietylle asialle on heti selkeä paikka ja
samankaltaiset asiat tapahtuvat konsistentimmin keskenään.

Eräs asia on vielä käsittelemättä. Jotta uuden projektin luonti \texttt{POST
/projects} -pyynnöllä tai olemassa olevan projektin muokkaaminen \texttt{PUT
/projects/42} -pyynnöllä onnistuu selaimella, HTML-lomakkeen pitää olla
olemassa kyseistä pyyntöä varten.

CRUD-toimintatapa ei suoraan kerro, millainen lomakkeen tuottavan HTTP-pyynnön
pitäisi olla, mutta sitä voidaan soveltaa seuraavasti:

\begin{samepage}
HTTP-metodin tulee selkeästi olla \texttt{GET}, koska pelkkää lomaketta
pyytäessä ei olla luomassa, muokkaamassa tai tuhoamassa mitään. Polkua varten
Rails käyttää seuraavaa ajatustapaa: samaten kuin resurssin
(\texttt{/projects}, \texttt{/projects/42}) perään voidaan lisätä
vaihtoehtoinen formaatti (esim. \texttt{/projects.xml},
\texttt{/projects/42.xml}), resurssin perään voidaan myös lisätä ikään kuin
vaihtoehtoinen \emph{aspekti}, joka resurssista halutaan.

\begin{tabular}{rll}
Metodi     & Polku                     & Selitys                                                 \\
\hline
\verb!GET! & \verb!/projects!          & Lista projekteista                                      \\
\verb!GET! & \verb!/projects.xml!      & Lista projekteista XML-muodossa                         \\
\hline
\verb!GET! & \verb!/projects/42!       & Projektin näkymä                                        \\
\verb!GET! & \verb!/projects/42.xml!   & Projektin näkymä XML-muodossa                           \\
\verb!GET! & \verb!/projects/42/edit!  & Projektin editointinäkymä; lomake projektin editointiin \\
\verb!GET! & \verb!/projects/new!      & Uuden projektin luontinäkymä; lomake projektin luontiin \\
\verb!GET! & \verb!/projects/new.xml!  & Alustava XML-pohja uuden projektin luontiin             \\
\end{tabular}
\end{samepage}

\section{Seuraava sessio}

Jäimme siihen, että ensimmäinen epäonnistunut testi on ''New Project -sivua ei
löydy''.

\texttt{script/rails generate} -komento tarjoaa tavan luoda tiedostopohjia
asioille, joita tullaan tekemään usein. Tutustumme siihen tarkemmin myöhemmin,
mutta käytämme tässä vaiheessa sen \eng{scaffold}-toimintoa.

\eng{Scaffold} (suom. rakennusteline) luo mallin sekä sille ohjaimen ja
näkymiä. Kaikki nämä ovat alustavia versioita, joita tulemme kehittämään
tarpeidemme mukaisesti.

\subsection{\eng{Scaffold} projektisivulle}

\begin{samepage}
Aja seuraava komento. Katsomme sitten, mitä tiedostoja se loi.

\begin{pygmented}{console}
% script/rails generate scaffold project name:string what:text when:text why:text
\end{pygmented}
\end{samepage}

\subsubsection{\eng{Model}}

Kuten sanottu, Railsin migrations-toiminto hoitaa olemassa olevan tietokannan
päivittämisen uuden koodin kanssa yhteensopivaksi. Rails ylläpitää kussakin
tietokannassa listaa siitä, mitkä migraatiot on jo toteutettu.

\begin{samepage}
\myref{Kuvassa}{fig:create-projects-migration} on
\texttt{CreateProjects}-migraation sisältö.

\begin{myfigure}[H]
\caption{\texttt{db/migrate/20100312170522\_create\_projects.rb}}
\label{fig:create-projects-migration}

\begin{pygmented}{ruby}
class CreateProjects < ActiveRecord::Migration
  def self.up
    create_table :projects do |t|
      t.string :name
      t.text :what
      t.text :when
      t.text :why

      t.timestamps
    end
  end

  def self.down
    drop_table :projects
  end
end
\end{pygmented}
\end{myfigure}
\end{samepage}

Tiedoston määrittelemä \texttt{up}-metodi suoritetaan migraatiota tehdessä ja
\texttt{down} sitä peruessa. \texttt{down}-metodin tulisi perua kaikki
\texttt{up}-metodin tekemät muutokset.

\texttt{create\_table}-metodikutsu luo uuden, projects-nimisen taulun
tietokantaan. Tauluun tulee vakiona id-kenttä. Sen lisäksi tauluun tulevat
name, what, when ja why -kentät, jotka listattiin \texttt{generate scaffold}
-komennon parametreinä.

Tauluun luodaan myös created\_at- ja updated\_at -kentät, joiden arvoja Rails
ylläpitää automaattisesti uusia tietokantarivejä luodessa ja olemassa olevia
päivittäessä. Mikäli tätä ei haluta, \texttt{t.timestamps}-rivi voidaan poistaa
tiedostosta, tai scaffold-generaattorille voidaan alunperin antaa parametri
\texttt{--no-timestamps}.

\begin{samepage}
Päivitä development-tietokanta ja tiedosto \texttt{db/schema.rb}.

\begin{pygmented}{console}
% rake db:migrate
==  CreateProjects: migrating =================================================
-- create_table(:projects)
   -> 0.0109s
==  CreateProjects: migrated (0.0116s) ========================================
\end{pygmented}
\end{samepage}

\begin{samepage}
\myref{Kuvan}{fig:project-model-00} listaama tiedosto sisältää varsinaisen
Project-mallin toteutuksen, joka on rajapinta tietokannan projects-tauluun.

\begin{myfigure}[H]
\caption{app/models/project.rb}
\label{fig:project-model-00}

\begin{pygmented}{ruby}
class Project < ActiveRecord::Base
end
\end{pygmented}
\end{myfigure}
\end{samepage}

Tällä hetkellä luokkamäärittely ei sisällä mitään muuta kuin
\texttt{ActiveRecord::Base}-luokasta perityt asiat.

ActiveRecordin dokumentaatio löytyy osoitteesta
\url{http://ar.rubyonrails.org/} (FIXME: sivu dokumentoi Rails~2:n
ActiveRecordia).

Voit kokeilla luokan tarjoamaa rajapintaa irb:ssä, interaktiivisessa
Ruby-kehotteessa, ajamalla komennon \texttt{script/rails console}. Esimerkki
kokeilusessiosta:

\begin{pygmented}{irb}
>> Project.create :name => '5w.fi', :what => 'The 5w website'
=> #<Project id: 1,
             name: "5w.fi",
             what: "The 5w website",
             when: nil,
             why: nil,
             created_at: "2010-03-12 17:52:31",
             updated_at: "2010-03-12 17:52:31">

>> Project.create :name => 'Embiggen the cromulence of 5w'
=> #<Project id: 2,
             name: "Embiggen the cromulence of 5w",
             what: nil,
             when: nil,
             why: nil,
             created_at: "2010-03-12 17:55:11",
             updated_at: "2010-03-12 17:55:11">

>> website = Project.find_by_name '5w.fi'
=> #<Project id: 1, name: "5w.fi", what: "The 5w website", ...>

>> website.when = 'Yesterday'
=> "Yesterday"

>> website.save
=> true

>> updated_projects = Project.where('updated_at > created_at').order('updated_at DESC')
=> #<ActiveRecord::Relation:0xb2670ac ...>

>> updated_projects.all
=> [#<Project id: 1, name: "5w.fi", ..., updated_at: "2010-03-12 17:56:54">]

>> Project.last.update_attributes :why => 'To jovialize the hackerspace'
=> true

>> updated_projects.reload
=> #<ActiveRecord::Relation:0xb2670ac>

>> updated_projects.all
=> [#<Project id: 2, name: "Embiggen the cromulence of 5w",
              why: "To jovialize the hackerspace", ...,
              updated_at: "2010-03-12 18:06:56">,
    #<Project id: 1, name: "5w.fi", ..., updated_at: "2010-03-12 17:56:54">]
\end{pygmented}

\subsubsection{Reititys}
\label{sec:projects-routing}

Rails käyttää asetustiedostoa \texttt{config/routes.rb} sen määrittelyyn, minkä
ohjaimen millekin metodille kukin HTTP-pyyntö ohjataan.

\eng{Scaffold}-generaattori lisäsi tiedostoon automaattisesti rivin
''\texttt{resources :projects}''.

\texttt{resources}-kutsu luo automaattisesti REST-tyylisen reitityksen
ohjaimelle, joka toteuttaa \texttt{index}-, \texttt{show}-, \texttt{new}-,
\texttt{edit}-, \texttt{create}-, \texttt{update}- ja \texttt{destroy}
-metodeista halutut.

\begin{samepage}
Voimme listata kaikki projektin reitit Rake-komennolla \texttt{routes}.

\begin{pygmented}{console}
% rake routes
             GET    /projects(.:format)          {:controller=>"projects", :action=>"index"}
    projects POST   /projects(.:format)          {:controller=>"projects", :action=>"create"}
 new_project GET    /projects/new(.:format)      {:controller=>"projects", :action=>"new"}
             GET    /projects/:id(.:format)      {:controller=>"projects", :action=>"show"}
             PUT    /projects/:id(.:format)      {:controller=>"projects", :action=>"update"}
     project DELETE /projects/:id(.:format)      {:controller=>"projects", :action=>"destroy"}
edit_project GET    /projects/:id/edit(.:format) {:controller=>"projects", :action=>"edit"}
\end{pygmented}
\end{samepage}

\begin{samepage}
Ensimmäisen sarakkeen arvot \texttt{projects}, \texttt{new\_project},
\texttt{project} ja \texttt{edit\_project} merkitsevät, että Rails on
automaattisesti luonut ohjainten ja näkymien käyttöön \texttt{\_path}- ja
\texttt{\_url} -loppuiset metodit, jotka palauttavat kyseisen polun/URL:n.

\begin{tabular}{ll}
Kutsu                                    & Palautettu merkkijono                  \\
\hline
\verb!projects_path!                     & \verb!/projects!                       \\
\verb!project_path(42)!                  & \verb!/projects/42!                    \\
\verb!project_path(Project.find(42))!    & \verb!/projects/42!                    \\
\verb!project_path(42, :format => :xml)! & \verb!/projects/42.xml!                \\
\verb!new_project_path!                  & \verb!/projects/new!                   \\
\verb!edit_project_path(42)!             & \verb!/projects/42/edit!               \\
\hline
\verb!projects_url!                      & \verb!http://example.net/projects!     \\
\verb!new_project_url!                   & \verb!http://example.net/projects/new! \\
\end{tabular}
\end{samepage}

\subsubsection{\eng{Controller} ja \eng{View}: \texttt{index}}
\label{sec:projects-controller-00-index}

\begin{samepage}
\myref{Kuva}{fig:projects-controller-00-index} listaa projects-ohjaimen
\texttt{index}-metodin. Rails kutsuu sitä, kun käyttäjä tekee
\texttt{GET}-kutsun \texttt{/projects}-resurssille.

\begin{myfigure}[H]
\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{index}-metodi}
\label{fig:projects-controller-00-index}

\begin{pygmented}{ruby}
  # GET /projects
  # GET /projects.xml
  def index
    @projects = Project.all

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml => @projects }
    end
  end
\end{pygmented}

\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{index}-metodi yksinkertaisempana}
\label{fig:projects-controller-01-index}

\begin{pygmented}{ruby}
  # GET /projects
  def index
    @projects = Project.scoped
  end
\end{pygmented}
\end{myfigure}
\end{samepage}

Metodi pyytää ylempänä esitellyltä \texttt{Project}-mallilta listan kaikista
projekteista ja sijoittaa sen \texttt{@projects}-jäsenmuuttujaan. Ohjaimen
asettamat jäsenmuuttujat ovat näkymien käytettävissä.

\texttt{respond\_to}-kutsulla metodi listaa formaatit, joilla se osaa
renderöidä resurssin käyttäjälle. \eng{Scaffold} listaa vakiona HTML:n ja
XML:n, joista jälkimmäinen soveltuu ohjelmallisen web-rajapinnan tarjoamiseen.

Listassa voisi olla esim. JSON ja Atom, mikäli haluamme tarjota JSON-rajapinnan
sekä Atom-syötteen.

Tutustumme myöhemmin vaihtoehtoisten formaattien tarjoamiseen, mutta tuemme
tässä vaiheessa vain HTML:ää yksinkertaisuuden nimissä. Muuta
\texttt{index}-metodi \myref{kuvan}{fig:projects-controller-01-index} mukaiseen
muotoon.

Muutimme samalla \texttt{Project.all}-kutsun \texttt{Project.scoped}-kutsuksi.
Ensimmäinen tekee välittömästi tietokantahaun ja palauttaa taulukon,
jälkimmäinen taas muodostaa \texttt{ActiveRecord::Relation}-olion, joka
suorittaa tietokantahaun vasta silloin, kun näkymä lopulta käyttää sitä kuin
taulukkoa.

Rails renderöi automaattisesti \texttt{projects/index}-näkymän, johon
tutustumme seuraavaksi.

Näkymien tiedostonimet noudattavat muotoa \emph{nimi.formaatti.kieli}, josta
esimerkkejä:

\begin{itemize}
\item
\emph{index.html.erb}: Formaatti on HTML. Näkymä prosessoidaan
ERB-templatekielellä.

\item
\emph{index.atom.builder}: Formaatti on Atom. Näkymä muodostetaan
Builder-kirjastoa käyttäen. Builder tarjoaa kätevän rajapinnan XML-dokumenttien
muodostamiseen.

\item
\emph{index.pdf.prawn}: Formaatti on PDF. Näkymä muodostetaan Prawn-kirjastoa
käyttäen. Prawn tarjoaa kätevän rajapinnan PDF-dokumenttien muodostamiseen.
\end{itemize}

\begin{samepage}
\myref{Kuva}{fig:projects-index-view-00} listaa \texttt{projects/index}-näkymän
sisällön.

\begin{myfigure}[H]
\caption{\texttt{app/views/projects/index.html.erb}}
\label{fig:projects-index-view-00}

\begin{pygmented}{html+erb}
<h1>Listing projects</h1>

<table>
  <tr>
    <th>Name</th><th>What</th><th>When</th><th>Why</th><th></th><th></th><th></th>
  </tr>

<% @projects.each do |project| %>
  <tr>
    <td><%= project.name %></td>
    <td><%= project.what %></td>
    <td><%= project.when %></td>
    <td><%= project.why %></td>
    <td><%= link_to 'Show', project %></td>
    <td><%= link_to 'Edit', edit_project_path(project) %></td>
    <td><%= link_to 'Destroy', project, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New project', new_project_path %>
\end{pygmented}
\end{myfigure}
\end{samepage}

Tiedostossa sellaisenaan oleva teksti päätyy tulosteeseen suoraan, mutta
Ruby-koodi erityisen \verb!<% ... %>! -lohkon sisällä suoritetaan lisäämättä
mitään tulosteeseen. \verb!<%= ... %>! -lohkon (huomaa \texttt{=}-merkki)
sisältämän koodin palauttama merkkijono taas lisätään tulosteeseen.

\verb!@projects.each do |project| ... end! -silmukka iteroi ohjaimessa
määritellyn \texttt{@projects}-olion yli niin, että \texttt{project}-muuttuja
viittaa kunkin iteraation kohdalla yksittäiseen \texttt{Project}-olioon, joka
vastaa tietokannan yksittäistä riviä. Silmukan sisällä laitetaan
td-elementtien sisälle projektin attribuutit \eng{name}, \eng{what}, \eng{when}
ja \eng{why}.

Lisäksi riville lisätään linkit projektikohtaiseen sivuun, projektin
muokkaussivuun ja projektin tuhoamiseen. Tässä hyödynnetään Railsin
\texttt{link\_to}-metodia, josta lisää myöhemmin.

Tiedosto käyttää myös \texttt{edit\_project\_path}- ja
\texttt{new\_project\_path} -metodeja, jotka käsiteltiin
\myref{kappaleessa}{sec:projects-routing}.

\begin{samepage}
\myref{Kuva}{fig:projects-index-view-00-example} listaa esimerkin silmukan
sisällä muodostuvasta HTML:stä.

\begin{myfigure}[H]
\caption{\texttt{app/views/projects/index.html.erb}: Esimerkkituloste}
\label{fig:projects-index-view-00-example}

\begin{pygmented}{html}
  <tr>
    <td>5w.fi</td>
    <td>The 5w website</td>
    <td>Yesterday</td>
    <td></td>
    <td><a href="/projects/1">Show</a></td>
    <td><a href="/projects/1/edit">Edit</a></td>
    <td><a href="/projects/1" data-confirm="Are you sure?" data-method="delete" rel="nofollow">Destroy</a></td>
  </tr>
\end{pygmented}
\end{myfigure}
\end{samepage}

\subsubsection{\eng{Controller} ja \eng{View}: \texttt{show}}

\begin{samepage}
\myref{Kuva}{fig:projects-controller-00-show} listaa projects-ohjaimen
\texttt{show}-metodin. Rails kutsuu sitä, kun käyttäjä tekee
\texttt{GET}-kutsun \texttt{/projects/N}-resurssille, jossa \texttt{N} on
projektin id-numero.

\begin{myfigure}[H]
\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{show}-metodi}
\label{fig:projects-controller-00-show}

\begin{pygmented}{ruby}
  # GET /projects/1
  # GET /projects/1.xml
  def show
    @project = Project.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.xml  { render :xml => @project }
    end
  end
\end{pygmented}

\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{show}-metodi yksinkertaisempana}
\label{fig:projects-controller-01-show}

\begin{pygmented}{ruby}
  # GET /projects/1
  def show
    @project = Project.find(params[:id])
  end
\end{pygmented}
\end{myfigure}
\end{samepage}

Metodi saa polussa olevan id-numeron Railsin määrittelemältä
\texttt{params}-oliolta kutsulla \texttt{params[:id]}.

Id-numero annetaan parametriksi \texttt{Project.find}-kutsulle, joka noutaa
tietokannasta numeroa vastaavan olion. Se sijoitetaan
\texttt{@projects}-jäsenmuuttujaan näkymää varten.

Yksinkertaista \texttt{show}-metodi
\myref{kuvan}{fig:projects-controller-01-show} mukaiseen muotoon.

\begin{samepage}
Rails renderöi automaattisesti \texttt{projects/show}-näkymän, joka on
\myref{kuvan}{fig:projects-show-view-00} mukainen.

\begin{myfigure}[H]
\caption{\texttt{app/views/projects/show.html.erb}}
\label{fig:projects-show-view-00}

\begin{pygmented}{html+erb}
<p><b>Name:</b> <%= @project.name %></p>

<p><b>What:</b> <%= @project.what %></p>

<p><b>When:</b> <%= @project.when %></p>

<p><b>Why:</b> <%= @project.why %></p>


<%= link_to 'Edit', edit_project_path(@project) %> |
<%= link_to 'Back', projects_path %>
\end{pygmented}
\end{myfigure}
\end{samepage}

\subsubsection{\eng{Controller} ja \eng{View}: \texttt{new}}
\label{sec:projects-controller-00-new}

\begin{samepage}
\myref{Kuva}{fig:projects-controller-00-new} listaa projects-ohjaimen
\texttt{new}-metodin. Rails kutsuu sitä, kun käyttäjä tekee \texttt{GET}-kutsun
\texttt{/projects/new}-resurssille.

\begin{myfigure}[H]
\caption{\texttt{app/controllers/projects\_controller.rb}: \texttt{new}-metodi}
\label{fig:projects-controller-00-new}

\begin{pygmented}{ruby}
  # GET /projects/new
  # GET /projects/new.xml
  def new
    @project = Project.new

    respond_to do |format|
      format.html # new.html.erb
      format.xml  { render :xml => @project }
    end
  end
\end{pygmented}

\caption{\texttt{app/controllers/projects\_controller.rb}: \texttt{new}-metodi
yksinkertaisempana}
\label{fig:projects-controller-01-new}

\begin{pygmented}{ruby}
  # GET /projects/new
  def new
    @project = Project.new
  end
\end{pygmented}
\end{myfigure}
\end{samepage}

Metodi muodostaa tyhjän \texttt{Project}-mallin olion kutsulla
\texttt{Project.new}. Kutsu ei tee tietokantaan mitään muutoksia, mutta luo
olion, jonka attribuutteja voitaisiin halutessa muokata ja joka voitaisiin
halutessa tallentaa tietokantaan. Olio sijoitetaan
\texttt{@project}-jäsenmuuttujaan näkymää varten.

Yksinkertaista \texttt{new}-metodi
\myref{kuvan}{fig:projects-controller-01-new} mukaiseen muotoon.

\begin{samepage}
Rails renderöi automaattisesti \texttt{project/new}-näkymän, joka on
\myref{kuvan}{fig:projects-new-view-00} mukainen.

\begin{myfigure}[H]
\caption{\texttt{app/views/projects/new.html.erb}}
\label{fig:projects-new-view-00}

\begin{pygmented}{html+erb}
<h1>New project</h1>

<%= render 'form' %>

<%= link_to 'Back', projects_path %>
\end{pygmented}
\end{myfigure}
\end{samepage}

Tässä hyödynnetään Railsin \eng{partials}-toimintoa. Koska uutta projektia
luodessa ja olemassa olevaa muokatessa HTML-lomake on käytännössä identtinen,
varsinainen lomake voidaan sijoittaa omaan tiedostoonsa, joka renderöidään
\texttt{render}-kutsulla kummastakin sivusta.

\begin{samepage}
\texttt{form}-\eng{partial} on \myref{kuvan}{fig:projects-form-partial-00}
mukainen. Huomaa tiedostonimen edessä oleva alaviiva, joka merkitsee partialia.

\begin{myfigure}[H]
\caption{\texttt{app/views/projects/\_form.html.erb}}
\label{fig:projects-form-partial-00}

\begin{pygmented}{html+erb}
<% form_for(@project) do |f| %>
  <%= f.error_messages %>

  <div class="field"><%= f.label :name %><br /><%= f.text_field :name %></div>
  <div class="field"><%= f.label :what %><br /><%= f.text_area :what %></div>
  <div class="field"><%= f.label :when %><br /><%= f.text_area :when %></div>
  <div class="field"><%= f.label :why %><br /><%= f.text_area :why %></div>
  <div class="actions"><%= f.submit %></div>
<% end %>
\end{pygmented}
\end{myfigure}
\end{samepage}

\texttt{form\_for} on Railsin metodi, joka helpottaa HTML-lomakkeiden
renderöintiä mallin (\eng{model}) perusteella.

\begin{samepage}
\myref{Kuva}{fig:projects-new-view-00-example} listaa esimerkin näkymän
muodostamasta HTML:stä.

\begin{myfigure}[H]
\caption{\texttt{app/views/projects/\_form.html.erb}: Esimerkkituloste}
\label{fig:projects-new-view-00-example}

\begin{pygmented}{html}
<form action="/projects" class="new_project" id="new_project" method="post">
  <input name="authenticity_token" type="hidden" value="EihD8pZXpR4nUnuxRu0Cmsw3EC3J9clhjgCyFJcuCYA=" />

  <div class="field">
    <label for="project_name">Name</label><br />
    <input id="project_name" name="project[name]" size="30" type="text" />
  </div>
  <div class="field">
    <label for="project_what">What</label><br />
    <textarea cols="40" id="project_what" name="project[what]" rows="20"></textarea>
  </div>
  <div class="field">
    <label for="project_when">When</label><br />
    <textarea cols="40" id="project_when" name="project[when]" rows="20"></textarea>
  </div>
  <div class="field">
    <label for="project_why">Why</label><br />
    <textarea cols="40" id="project_why" name="project[why]" rows="20"></textarea>
  </div>
  <div class="actions">
    <input id="project_submit" name="commit" type="submit" value="Create Project" />
  </div>
</form>
\end{pygmented}
\end{myfigure}
\end{samepage}

\texttt{form\_for}-\emph{\eng{helper}} generoi automaattisesti
\texttt{authenticity\_token}-kentän lomakkeeseen. Rails tarkistaa kyseisen
parametrin arvon jokaisen \texttt{POST}-, \texttt{PUT}- ja \texttt{DELETE}
-pyynnön yhteydessä
CSRF-haavoittuvuuden\footnote{\url{http://en.wikipedia.org/wiki/Cross-site\_request\_forgery}}
välttämiseksi.

\subsubsection{\eng{Controller} ja \eng{View}: \texttt{edit}}

\begin{samepage}
\myref{Kuva}{fig:projects-controller-00-edit} listaa projects-ohjaimen
\texttt{edit}-metodin. Rails kutsuu sitä, kun käyttäjä tekee
\texttt{GET}-kutsun \texttt{/projects/N/edit}-resurssille, jossa \texttt{N} on
projektin id-numero.

\begin{myfigure}[H]
\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{edit}-metodi}
\label{fig:projects-controller-00-edit}

\begin{pygmented}{ruby}
  # GET /projects/1/edit
  def edit
    @project = Project.find(params[:id])
  end
\end{pygmented}
\end{myfigure}
\end{samepage}

Metodi noutaa tietokannasta polussa olevan id-numeron mukaisen
\texttt{Project}-mallin olion.

\begin{samepage}
Rails renderöi automaattisesti \texttt{project/edit}-näkymän, joka on
\myref{kuvan}{fig:projects-edit-view-00} mukainen.

\begin{myfigure}[H]
\caption{\texttt{app/views/projects/edit.html.erb}}
\label{fig:projects-edit-view-00}

\begin{pygmented}{html+erb}
<h1>Editing project</h1>

<%= render 'form' %>

<%= link_to 'Show', @project %> |
<%= link_to 'Back', projects_path %>
\end{pygmented}
\end{myfigure}
\end{samepage}

Näkymä renderöi \texttt{form}-partialin, jonka sisältö näytettiin
\myref{kuvassa}{fig:projects-form-partial-00}.

\subsubsection{\eng{Controller} ja \eng{View}: \texttt{create}}

\begin{samepage}
\myref{Kuva}{fig:projects-controller-00-create} listaa projects-ohjaimen
\texttt{create}-metodin. Rails kutsuu sitä, kun käyttäjä tekee
\texttt{POST}-kutsun \texttt{/projects}-resurssille.

\begin{myfigure}[H]
\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{create}-metodi}
\label{fig:projects-controller-00-create}

\begin{pygmented}{ruby}
  # POST /projects
  # POST /projects.xml
  def create
    @project = Project.new(params[:project])

    respond_to do |format|
      if @project.save
        format.html { redirect_to(@project, :notice => 'Project was successfully created.') }
        format.xml  { render :xml => @project, :status => :created, :location => @project }
      else
        format.html { render :action => "new" }
        format.xml  { render :xml => @project.errors, :status => :unprocessable_entity }
      end
    end
  end
\end{pygmented}

\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{create}-metodi yksinkertaisempana}
\label{fig:projects-controller-01-create}

\begin{pygmented}{ruby}
  # POST /projects
  def create
    @project = Project.new(params[:project])

    if @project.save
      redirect_to(@project, :notice => 'Project created.')
    else
      render :action => "new"
    end
  end
\end{pygmented}
\end{myfigure}
\end{samepage}

Yksinkertaista \texttt{create}-metodi
\myref{kuvan}{fig:projects-controller-01-create} mukaiseen muotoon.

Metodi muodostaa uuden \texttt{Project}-mallin olion täydentäen sen kentät
käyttäjältä tulevien parametrien perusteella. Olio sijoitetaan
\texttt{@project}-jäsenmuuttujaan.

Mikäli olion tallentaminen tietokantaan \texttt{@project.save}-kutsulla
onnistuu, käyttäjän sessioon lisätään viesti onnistuneesta luonnista ja selain
ohjataan juuri luodun projektin sivulle, joka tulee näyttämään viestin.

Mikäli tallentaminen epäonnistuu, käyttäjälle renderöidään
\texttt{projects/new}-näkymä. Näkymää renderöidessä \texttt{@project} sisältää
attribuutit käyttäjän antamassa muodossa, sekä listan virheistä. Näin
\texttt{projects/\_form}-\eng{partial} säilyttää kentissä käyttäjän jo
syöttämät arvot ja kertoo epäonnistumisen syyt.

\subsubsection{\eng{Controller} ja \eng{View}: \texttt{update}}

\begin{samepage}
\myref{Kuva}{fig:projects-controller-00-update} listaa projects-ohjaimen
\texttt{update}-metodin. Rails kutsuu sitä, kun käyttäjä tekee
\texttt{PUT}-kutsun \texttt{/projects/N}-resurssille, jossa \texttt{N} on
projektin id-numero.

\begin{myfigure}[H]
\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{update}-metodi}
\label{fig:projects-controller-00-update}

\begin{pygmented}{ruby}
  # PUT /projects/1
  # PUT /projects/1.xml
  def update
    @project = Project.find(params[:id])

    respond_to do |format|
      if @project.update_attributes(params[:project])
        format.html { redirect_to(@project, :notice => 'Project was successfully updated.') }
        format.xml  { head :ok }
      else
        format.html { render :action => "edit" }
        format.xml  { render :xml => @project.errors, :status => :unprocessable_entity }
      end
    end
  end
\end{pygmented}

\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{update}-metodi yksinkertaisempana}
\label{fig:projects-controller-01-update}

\begin{pygmented}{ruby}
  # PUT /projects/1
  def update
    @project = Project.find(params[:id])

    if @project.update_attributes(params[:project])
      redirect_to(@project, :notice => 'Project updated.')
    else
      render :action => "edit"
    end
  end
\end{pygmented}
\end{myfigure}
\end{samepage}

Yksinkertaista \texttt{update}-metodi
\myref{kuvan}{fig:projects-controller-01-update} mukaiseen muotoon.

Metodi noutaa tietokannasta polussa olevan id-numeron mukaisen
\texttt{Project}-mallin olion ja sijoittaa sen
\texttt{@project}-jäsenmuuttujaan.

Mikäli olion attribuuttien päivittäminen käyttäjältä tulevien parametrien
perusteella sekä olion tallentaminen tietokantaan
\texttt{@project.update\_attributes}-kutsulla onnistuu, käyttäjän sessioon
lisätään viesti onnistuneesta päivityksestä ja selain ohjataan juuri päivitetyn
projektin sivulle, joka tulee näyttämään viestin.

Mikäli päivitys epäonnistuu, käyttäjälle renderöidään
\texttt{projects/edit}-näkymä. Näkymää renderöidessä \texttt{@project} sisältää
attribuutit käyttäjän antamassa muodossa, sekä listan virheistä. Näin
\texttt{projects/\_form}-\eng{partial} säilyttää kentissä käyttäjän jo
syöttämät arvot ja kertoo epäonnistumisen syyt.

\subsubsection{\eng{Controller} ja \eng{View}: \texttt{destroy}}

\begin{samepage}
\myref{Kuva}{fig:projects-controller-00-destroy} listaa projects-ohjaimen
\texttt{destroy}-metodin. Rails kutsuu sitä, kun käyttäjä tekee
\texttt{DELETE}-kutsun \texttt{/projects/N}-resurssille, jossa \texttt{N} on
projektin id-numero.

\begin{myfigure}[H]
\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{destroy}-metodi}
\label{fig:projects-controller-00-destroy}

\begin{pygmented}{ruby}
  # DELETE /projects/1
  # DELETE /projects/1.xml
  def destroy
    @project = Project.find(params[:id])
    @project.destroy

    respond_to do |format|
      format.html { redirect_to(projects_url) }
      format.xml  { head :ok }
    end
  end
\end{pygmented}

\caption{\texttt{app/controllers/projects\_controller.rb}:
\texttt{destroy}-metodi yksinkertaisempana}
\label{fig:projects-controller-01-destroy}

\begin{pygmented}{ruby}
  # DELETE /projects/1
  def destroy
    @project = Project.find(params[:id])
    @project.destroy

    redirect_to(projects_url)
  end
\end{pygmented}
\end{myfigure}
\end{samepage}

Yksinkertaista \texttt{destroy}-metodi
\myref{kuvan}{fig:projects-controller-01-destroy} mukaiseen muotoon.

Metodi noutaa tietokannasta polussa olevan id-numeron mukaisen
\texttt{Project}-mallin olion ja sijoittaa sen
\texttt{@project}-jäsenmuuttujaan. Tietokannan rivi tuhotaan
\texttt{@project.destroy}-kutsulla.

Lopuksi selain ohjataan projektilistaan.

\subsubsection{\eng{Layout}}

Yllä esitellyt näkymät tarvivat ympärilleen varsinaisen HTML-sivun. Tämän
tehtävän hoitaa \eng{layout}.

\begin{samepage}
\eng{Scaffold}-generaattori loi tiedoston
\texttt{app/views/layouts/projects.html.erb} layoutiksi projects-ohjaimelle,
mutta luomme sen sijaan globaalin
\texttt{app/views/layouts/application.html.erb}-tiedoston mukaillen
\texttt{projects.html.erb}:tä \myref{kuvan}{fig:application-layout-00}
mukaisesti.

\begin{myfigure}[H]
\caption{\texttt{app/views/layouts/application.html.erb}}
\label{fig:application-layout-00}

\begin{pygmented}{html+erb}
<!DOCTYPE html>
<html>
<head>
  <title><%= controller.action_name %> &ndash; <%= controller.controller_name %> &ndash; 5w</title>
  <%= javascript_include_tag 'http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js' %>
  <%= javascript_include_tag 'rails', :cache => true %>
  <%= csrf_meta_tag %>
</head>
<body>

<p class="notice"><%= notice %></p>

<%= yield %>

</body>
</html>
\end{pygmented}
\end{myfigure}
\end{samepage}

\texttt{controller.action\_name}- ja \texttt{controller.controller\_name}
-metodien käyttö sivun otsikossa saa aikaan otsikon tyyliin ''index -- projects
-- 5w''. Tämä on väliaikainen otsikko, joka tullaan muuttamaan paremmaksi
aikanaan.

\texttt{javascript\_include\_tag}-kutsut muodostavat \texttt{script}-tagit,
joiden perusteella selain lataa jQuery-kirjaston Googlen palvelusta ja
jQuery-UJS-projektin \texttt{rails.js}-tiedoston palvelimeltamme. Jälkimmäinen
toteuttaa Railsin JavaScript-toiminnot jQueryn kanssa.

\texttt{csrf\_meta\_tag}-kutsu lisää sivuun metadataa, jonka perusteella
JavaScript-koodi (kuten \texttt{rails.js}) kykenee tarvittaessa olemaan
yhteensopiva \myref{kappaleessa}{sec:projects-controller-00-new} mainitun
CSRF-suojauksen kanssa.

\texttt{notice}-kutsu lisää sivulle mahdollisen käyttäjän sessioon lisätyn
viestin, kuten ''Project created''. \texttt{yield}-kutsu taas saa aikaan
varsinaisen näkymän renderöinnin kyseiseen kohtaan layoutia.

\begin{samepage}
Tuhoa \texttt{projects.html.erb}-layout. Tuhoa myös
\eng{scaffold}-generaattorin luoma tiedosto
\texttt{public/stylesheets/scaffold.css}. Tulemme määrittelemään itse kaiken
ulkoasun.

\begin{pygmented}{console}
% rm app/views/layouts/projects.html.erb public/stylesheets/scaffold.css
\end{pygmented}
\end{samepage}

\begin{samepage}
Imuroi \texttt{public/javascripts}-hakemistoon yllä mainittu
jQuery-UJS-projektin tiedosto \texttt{rails.js}.

\begin{pygmented}{console}
% mkdir -p public/javascripts
% wget -O public/javascripts/rails.js http://github.com/rails/jquery-ujs/raw/master/src/rails.js
\end{pygmented}
\end{samepage}

\begin{samepage}
Tee commit layoutin ja \texttt{rails.js}:n lisäämisestä.

\begin{pygmented}{console}
% git add app/views/layouts/application.html.erb public
% git commit -m 'Add initial layout and jQuery-UJS'
\end{pygmented}
\end{samepage}

Voit kokeilla sovellusta ajamalla komennon \texttt{script/rails server} ja
avaamalla web-sivun \url{http://0.0.0.0/projects}.

\subsubsection{Yksikkötestit}

\begin{samepage}
\eng{Scaffold}-generaattori loi \texttt{spec}-hakemiston alle alustavia
tiedostoja yksikkötestausta varten. Tutustumme niihin tarkemmin siinä
vaiheessa, kun teemme ensimmäisiä yksikkötestejä. Poista kuitenkin alustavat
\eng{request}- ja \eng{view} -testit tässä vaiheessa, koska Cucumber-speksimme
testaa ja tulee testaamaan samat asiat.

\begin{pygmented}{console}
% rm -r spec/requests/projects_spec.rb spec/views/projects
\end{pygmented}
\end{samepage}

\begin{samepage}
Tee myös \myref{kuvan}{fig:projects-controller-spec-scoped-call} mukainen
muutos. Haluamme \texttt{projects\_controller}-testin tarkistavan, että
\texttt{index}-metodi tekee \texttt{Project.all}-kutsun sijaan
\texttt{Project.scoped}-kutsun
\myref{kappaleessa}{sec:projects-controller-00-index} tekemämme muutoksen
mukaisesti.

\begin{myfigure}[H]
\caption{\texttt{spec/controllers/projects\_controller\_spec.rb}:
\texttt{Project.scoped}-kutsu \texttt{Project.all}-kutsun sijaan}
\label{fig:projects-controller-spec-scoped-call}

\begin{pygmented}{diff}
--- a/spec/controllers/projects_controller_spec.rb
+++ b/spec/controllers/projects_controller_spec.rb
@@ -8,7 +8,7 @@ describe ProjectsController do
 
   describe "GET index" do
     it "assigns all projects as @projects" do
-      Project.stub(:all) { [mock_project] }
+      Project.stub(:scoped) { [mock_project] }
       get :index
       assigns(:projects).should eq([mock_project])
     end
\end{pygmented}

(Huomaa diff-formaatti. Sanavälillä alkavat rivit ovat tiedostossa jo olevaa
sisältöä kontekstina. Miinusmerkillä alkavat rivit merkitsevät poistettavia
rivejä ja plusmerkillä alkavat rivit ovat kyseisiin väleihin lisättäviä
rivejä.)
\end{myfigure}
\end{samepage}

\subsubsection{Cucumber-testien ajo ja commit}

\begin{samepage}
Jotta pääsemme Cucumber-speksissämme eteenpäin, joudumme tekemään vielä yhden
asian. Tarkka virheilmoitus oli:

\begin{pygmented}{console}
      Can't find mapping from "the New Project page" to a path.
      Now, go and add a mapping in features/support/paths.rb (RuntimeError)
\end{pygmented}
\end{samepage}

Cucumber ei tiedä, mitä polkua ''\eng{the New Project page}'' merkitsee.
Voisimme kertoa sille, että polku on \texttt{/projects/new}, mutta on parempi
käyttää \texttt{new\_project\_path}-metodia, jonka opimme
\myref{kappaleessa}{sec:projects-routing}.

Lisäämme saman tien muutkin mahdolliset projects-reitit.

\begin{samepage}
Tee \texttt{features/support/paths.rb}-tiedostoon
\myref{kuvan}{fig:paths-new-project} mukainen muutos.

\begin{myfigure}[H]
\caption{\texttt{features/support/paths.rb}: ''\eng{the New Project page}''}
\label{fig:paths-new-project}

\begin{pygmented}{diff}
--- a/features/support/paths.rb
+++ b/features/support/paths.rb
@@ -17,6 +17,19 @@ module NavigationHelpers
     #   when /^(.*)'s profile page$/i
     #     user_profile_path(User.find_by_login($1))
 
+    when 'the Projects page'
+      projects_path
+    when 'a Project page'
+      project_path(Project.first)
+    when /^the Project page for "(.*)"$/
+      project_path(Project.find_by_name($1))
+    when 'the New Project page'
+      new_project_path
+    when 'an Edit Project page'
+      edit_project_path(Project.first)
+    when /^the Edit Project page for "(.*)"$/
+      edit_project_path(Project.find_by_name($1))
+
     else
       raise "Can't find mapping from \"#{page_name}\" to a path.\n" +
         "Now, go and add a mapping in #{__FILE__}"
\end{pygmented}
\end{myfigure}
\end{samepage}

\begin{samepage}
Nyt kun ajamme Rake-komennon \texttt{cucumber:wip}, aiemmin epäonnistunut testi
onnistuu.

\begin{pygmented}{console}
% rake cucumber:wip
\end{pygmented}
\end{samepage}

\begin{samepage}
Tee vielä commit projects-scaffoldingista.

\begin{pygmented}{console}
% git add .
% git commit -m 'Add initial projects scaffolding'
\end{pygmented}
\end{samepage}

\subsection{Syötteen validointi}

\begin{samepage}
Cucumber kertoo ensimmäisen virheilmoituksen muodossa, mitä tulee tehdä
seuraavaksi.

\begin{pygmented}{console}
% rake cucumber:wip
...
      | name | what | when | why | error          |
      |      | x    | x    | x   | can't be blank |
      expected #has_content?("can't be blank") to return true, got false
      features/manage_projects.feature:30:in `Then I should see "<error>"'
\end{pygmented}
\end{samepage}

Käyttäjän syötteen validointi ei tapahtunut speksin määräämällä tavalla:
virheilmoitusta ''\eng{\dots can't be blank}'' ei tullut, vaikka Name-kenttä
jätettiin tyhjäksi.

Toteutamme ensin validoinnin testaamisen \texttt{Project}-mallin
yksikkötesteissä, eli rajapinnan tasolla.

Käytämme Factory Girl
-kirjastoa\footnote{\url{http://github.com/thoughtbot/factory\_girl\#readme}}
mallien testiolioiden luomiseen.

\begin{samepage}
Lisää seuraavat rivit Gemfile-tiedostoon ja aja \texttt{bundle install}, jotta
kyseinen gem asentuu.

\begin{pygmented}{ruby}
# Use Factory Girl to generate test objects.
gem 'factory_girl', :group => :test
\end{pygmented}
\end{samepage}

\begin{samepage}
Tee tiedostoon \texttt{config/environment.rb} seuraava muutos, jotta Factory
Girl on testien käytettävissä.

\begin{pygmented}{diff}
--- a/config/environment.rb
+++ b/config/environment.rb
@@ -1,3 +1,5 @@
+require 'factory_girl' if ENV['RAILS_ENV'] == 'test'
+
 # Load the rails application
 require File.expand_path('../application', __FILE__)
 
\end{pygmented}
\end{samepage}

\begin{samepage}
Luo tiedosto \texttt{spec/factories.rb} \myref{kuvan}{fig:factories-00-project}
mukaisesti.

\begin{myfigure}[H]
\caption{\texttt{spec/factories.rb}}
\label{fig:factories-00-project}

\begin{pygmented}{ruby}
Factory.define :project do |f|
  f.name '5w.fi'
  f.what 'The 5w portal'
  f.when 'Yesterday'
  f.why  'To have an excellent website'
end
\end{pygmented}
\end{myfigure}
\end{samepage}

Tiedosto määrittelee validin \texttt{Project}-mallin olion, joka voidaan
jatkossa luoda yksikkötesteissä mm. \texttt{Factory.build(:project)}-kutsulla.

\begin{samepage}
Muokkaa tiedosto \texttt{spec/models/project\_spec.rb}
\myref{kuvan}{fig:project-model-spec-00} mukaiseksi.

\begin{myfigure}[H]
\caption{\texttt{spec/models/project\_spec.rb}}
\label{fig:project-model-spec-00}

\begin{pygmented}{ruby}
require 'spec_helper'

describe Project do
  it "should be valid with correct attributes" do
    project = Factory.build :project
    project.should be_valid
  end

  [:name, :what, :when, :why].each do |attribute|
    it "should not be valid when attribute '#{attribute}' is blank" do
      project = Factory.build :project, attribute => ''

      project.should_not be_valid
      project.errors[attribute].should include "can't be blank"
      project.errors.count.should be 1
    end
  end
end
\end{pygmented}
\end{myfigure}
\end{samepage}

\begin{samepage}
Aja yksikkötestit Rake-komennolla \texttt{spec}.

\begin{pygmented}{console}
% rake spec
................FFFF

1) Project should not be valid when attribute 'name' is blank
    Failure/Error: project.should_not be_valid
    expected valid? to return false, got true

2) Project should not be valid when attribute 'what' is blank
3) Project should not be valid when attribute 'when' is blank
4) Project should not be valid when attribute 'why' is blank
\end{pygmented}
\end{samepage}

Ensimmäiset epäonnistuneet yksikkötestit kertovat, mitä tulee toteuttaa
seuraavaksi: \texttt{Project}-mallin pitää tarkistaa, että yksikään
attribuuteista ei ole tyhjä.

\begin{samepage}
Tee seuraava muutos tiedostoon \texttt{app/models/project.rb}:

\begin{pygmented}{diff}
--- a/app/models/project.rb
+++ b/app/models/project.rb
@@ -1,2 +1,3 @@
 class Project < ActiveRecord::Base
+  validates_presence_of :name, :what, :when, :why
 end
\end{pygmented}
\end{samepage}

\begin{samepage}
Nyt yksikkötestit onnistuvat.

\begin{pygmented}{console}
% rake spec
....................

Finished in 0.290829387 seconds
20 examples, 0 failures
\end{pygmented}

Kukin piste merkitsee onnistunutta testiä.
\end{samepage}

\begin{samepage}
Tee muutoksesta commit.

\begin{pygmented}{console}
% git status
  Changed but not updated:
        modified:   Gemfile
        modified:   app/models/project.rb
        modified:   spec/models/project_spec.rb
        modified:   spec/spec_helper.rb
  Untracked files:
        spec/factories.rb
% git add Gemfile spec/spec_helper.rb spec/factories.rb
% git commit -m 'Add Factory Girl; define factory for Project'

% git status
  Changed but not updated:
        modified:   app/models/project.rb
        modified:   spec/models/project_spec.rb
% git commit -a -m 'Project: validate presence of attributes'
\end{pygmented}
\end{samepage}

Ajamalla Rake-komennon \texttt{cucumber:wip} näemme, että aiemmin epäonnistunut
testi onnistuu nyt.

\subsection{Projektin aikaleima}

\begin{samepage}
Cucumber kertoo jälleen ensimmäisen virheilmoituksen muodossa, mitä tulee tehdä
seuraavaksi.

\begin{pygmented}{console}
% rake cucumber:wip
...
You can implement step definitions for undefined steps with these snippets:

Then /^I should see a timestamp no older than 1 minute$/ do
  pending # express the regexp above with the code you wish you had
end
\end{pygmented}
\end{samepage}

\begin{samepage}
Meidän pitää toteuttaa määrittely ''\eng{I should see a timestamp\dots}''
-testille. Luo \texttt{relative\_time\_steps.rb}-tiedosto
\myref{kuvan}{fig:relative-time-steps} mukaisesti.

\begin{myfigure}[H]
\caption{\texttt{features/step\_definitions/relative\_time\_steps.rb}}
\label{fig:relative-time-steps}

\begin{pygmented}{ruby}
Then /^I should see a timestamp no (older|newer) than (.*)$/ do |direction, dur|
  seconds = ChronicDuration.parse dur
  if seconds.nil?
    raise ArgumentError, "Invalid duration #{dur.inspect}"
  end

  timestamps = all(:css, 'abbr.timestamp').map do |node|
    Time.iso8601(node['title']) rescue nil
  end.compact

  if direction == 'older'
    timestamps.should have_a_member be >= Time.now-seconds
  else
    timestamps.should have_a_member be <= Time.now+seconds
  end
end
\end{pygmented}
\end{myfigure}
\end{samepage}

Konvertoimme ensin englanninkielisen aikajakson sekunneiksi. Haemme sitten
web-sivulta kaikki \verb!<abbr class="timestamp">! -elementit, joiden
\texttt{title}-attribuutti sisältää aikaleiman ISO~8601
-formaatissa\footnote{\url{http://en.wikipedia.org/wiki/ISO\_8601}}. Lopuksi
tarkistamme, että vähintään yksi niistä sijoittuu halutulle aikavälille.

\begin{samepage}
Tarvitsemme ChronicDuration-kirjaston. Lisää seuraavat rivit
Gemfile-tiedostoon ja aja \texttt{bundle install}, jotta kyseinen gem asentuu.

\begin{pygmented}{ruby}
# Used by features/step_definitions/relative_time_steps.rb.
gem 'chronic_duration', :group => :test
\end{pygmented}
\end{samepage}

\begin{samepage}
Tarvitsemme myös \texttt{have\_a\_member}-\emph{matcherin}. Imuroi se projektiin.

\begin{pygmented}{console}
(http://gist.github.com/332500 / raw)
% wget -O features/support/have_member_matcher.rb \
> http://gist.github.com/raw/332500/855cda194d345b42d754afe4fc08f8177d2d3e1b/have_a_member_matcher.rb
\end{pygmented}
\end{samepage}

\begin{samepage}
Tee muutoksista commit.

\begin{pygmented}{console}
% git add .
% git commit -m 'Add relative_time_steps'
\end{pygmented}
\end{samepage}

\begin{samepage}
Cucumber kertoo taas, mitä tulee tehdä seuraavaksi.

\begin{pygmented}{console}
% rake cucumber:wip
...
  Scenario: Add a new project                           # features/manage_projects.feature:7
    Given I am on the New Project page                  # features/step_definitions/web_steps.rb:18
...
    And I should see a timestamp no older than 1 minute # features/step_definitions/relative_time_steps.rb:1
      expected [] to have a member be >= 2010-03-15 06:33:40 +0200
\end{pygmented}
\end{samepage}

\begin{samepage}
Testi epäonnistuu, koska sivulta ei löydy aikaleimaa. Lisäämme siis sellaisen
näkymään \myref{kuvan}{fig:projects-view-add-timestamps} mukaisesti.

\begin{myfigure}[H]
\caption{Aikaleiman lisääminen näkymiin}
\label{fig:projects-view-add-timestamps}

\begin{pygmented}{diff}
--- a/app/views/projects/index.html.erb
+++ b/app/views/projects/index.html.erb
@@ -6,6 +6,7 @@
     <th>What</th>
     <th>When</th>
     <th>Why</th>
+    <th>Created on</th>
     <th></th>
     <th></th>
     <th></th>
@@ -17,6 +18,7 @@
     <td><%= project.what %></td>
     <td><%= project.when %></td>
     <td><%= project.why %></td>
+    <td><%= timestamp project.created_at, '%F' %></td>
     <td><%= link_to 'Show', project %></td>
     <td><%= link_to 'Edit', edit_project_path(project) %></td>
     <td><%= link_to 'Destroy', project, :confirm => 'Are you sure?', :method => :delete %></td>
\end{pygmented}

\begin{pygmented}{diff}
--- a/app/views/projects/show.html.erb
+++ b/app/views/projects/show.html.erb
@@ -18,6 +18,7 @@
   <%= @project.why %>
 </p>
 
+<p>Created <%= timestamp @project.created_at, 'on %F' %></p>
 
 <%= link_to 'Edit', edit_project_path(@project) %> |
 <%= link_to 'Back', projects_path %>
\end{pygmented}
\end{myfigure}
\end{samepage}

\begin{samepage}
Sen sijaan, että loisimme haluamamme \texttt{abbr}-elementin aina manuaalisesti
tyyliin\dots

\begin{pygmented}{html+erb}
<abbr class="timestamp" title="<%= project.created_at.iso8601 %>">
  <%= project.created_at.strftime '%F' %>
</abbr>
\end{pygmented}

\dots kutsumme \texttt{timestamp}-\emph{helperiä}, jonka määrittelemme
seuraavaksi. Helperit ovat yksinkertaisesti tietyssä paikassa määriteltyjä
metodeja, jotka ovat ohjainten ja näkymien käytettävissä.
\end{samepage}

\begin{samepage}
Kirjoitamme ensin yksikkötestit haluamallamme tavalla toimivalle metodille.
Luo \texttt{application\_helper\_spec.rb}
\myref{kuvan}{fig:timestamp-helper-spec-00} mukaisesti.

\begin{myfigure}[H]
\caption{\texttt{spec/helpers/application\_helper\_spec.rb}: Yksikkötestit
\texttt{timestamp}-helperille}
\label{fig:timestamp-helper-spec-00}

\begin{pygmented}{ruby}
require 'rexml/document'
require 'spec_helper'

describe ApplicationHelper do
  def helper
    @helper ||= ApplicationController.helpers
  end

  describe 'timestamp' do
    before :all do
      @time = Time.iso8601 '2010-02-03T04:05:06+07:00'
    end

    it 'should return an abbr element with correct formatting' do
      fmt = 'blah %F %T %z blah'
      doc = REXML::Document.new ERB::Util.h(helper.timestamp(@time, fmt))
      doc.root.name.should == 'abbr'
      doc.root.attributes['class'].should == 'timestamp'
      Time.iso8601(doc.root.attributes['title']).should == @time
      doc.root.text.should == @time.strftime(fmt)
    end

    it 'should have a default formatting' do
      doc = REXML::Document.new ERB::Util.h(helper.timestamp(@time))
      doc.root.text.should == @time.strftime('%F %T')
    end

    it 'should escape unsafe format' do
      fmt = '<%F & %T>'
      doc = REXML::Document.new ERB::Util.h(helper.timestamp(@time, fmt))
      doc.root.text.should == @time.strftime(fmt)
    end

    it 'should pass through safe format' do
      fmt = '<strong>%F %T</strong>'.html_safe
      doc = REXML::Document.new ERB::Util.h(helper.timestamp(@time, fmt))
      doc.root.elements[1].name.should == 'strong'
      doc.root.elements[1].text.should == @time.strftime('%F %T')
    end
  end
end
\end{pygmented}
\end{myfigure}
\end{samepage}

Parsetamme kussakin testissä Rubyn standardikirjastoon kuuluvalla
\texttt{REXML}:llä \texttt{timestamp}-metodin palauttaman merkkijonon.

Testaamme ensin, että elementti on \texttt{abbr} ja että sillä on attribuutti
\texttt{class="timestamp"} ja ISO~8601 -aikaleiman sisältävä attribuutti
\texttt{title}. Testaamme myös, että elementti sisältää pyydetyllä tavalla
muotoillun merkkijonon.

Seuraavassa testissä varmistamme, että jos \texttt{timestamp}-kutsussa ei
anneta formaattia parametriksi, metodi käyttää vakioarvoa \verb!'%F %T'!.

Kolmannessa testissä varmistamme, että merkit \texttt{<}, \texttt{>} ja
\texttt{\&} päätyvät HTML:ään \emph{paettuna} oikein.

Lopuksi varmistamme, että \texttt{html\_safe}-metodilla turvalliseksi
määritellyn merkkijonon vastaavat merkit päätyvät tulosteeseen sellaisenaan.

\begin{samepage}
Yksikkötestien (\texttt{rake spec}) ensimmäinen virheilmoitus kertoo, että
metodia \texttt{timestamp} ei ole. Luo sellainen.

\begin{myfigure}[H]
\begin{pygmented}{diff}
--- a/app/helpers/application_helper.rb
+++ b/app/helpers/application_helper.rb
@@ -1,2 +1,6 @@
 module ApplicationHelper
+  def timestamp time, format
+    content_tag :abbr, time.strftime(format),
+                :class => 'timestamp', :title => time.iso8601
+  end
 end
\end{pygmented}
\end{myfigure}
\end{samepage}

Käytämme Railsin \texttt{content\_tag}-helperiä, joka yksinkertaisesti
muodostaa HTML-elementin halutulla sisällöllä ja halutuilla attribuuteilla.

\texttt{Time}-olion\footnote{\url{http://ruby-doc.org/ruby-1.9/classes/Time.html}}
\texttt{strftime}-metodi palauttaa halutun formaatin mukaisesti muotoillun
merkkijonon. \texttt{iso8601}-metodi taas palauttaa ISO~8601 -standardin
mukaisen merkkijonon.

\begin{samepage}
Nyt yksikkötestien ensimmäinen epäonnistuminen tapahtuu kohdassa
''\eng{ApplicationHelper timestamp should have a default formatting}'' ja
virheilmoitus on ''\eng{wrong number of arguments (1 for 2)}''. Määritä
\texttt{timestamp}-metodin \texttt{format}-parametrille vakioarvo. \texttt{'\%F
\%T'} vastaa formaattia \texttt{YYYY-MM-DD HH:MM:SS}.

\begin{myfigure}[H]
\begin{pygmented}{diff}
--- a/app/helpers/application_helper.rb
+++ b/app/helpers/application_helper.rb
@@ -1,5 +1,5 @@
 module ApplicationHelper
-  def timestamp time, format
+  def timestamp time, format='%F %T'
     content_tag :abbr, time.strftime(format),
                 :class => 'timestamp', :title => time.iso8601
   end
\end{pygmented}
\end{myfigure}
\end{samepage}

Nyt yksikkötestien ensimmäinen epäonnistuminen tapahtuu kohdassa
''\eng{ApplicationHelper timestamp should escape unsafe format}'' ja
virheilmoitus on ''\eng{REXML::ParseException: malformed XML: missing tag
start: \dots Last 80 unconsumed characters: \texttt{<2010-02-02 \&
21:05:06></abbr>>}}''.

\begin{samepage}
Erikoismerkit selvästi päätyivät tulosteeseen sellaisenaan ja REXML ei kyennyt
tulkitsemaan epävalidia XML:ää. Muuta metodi suodattamaan
\texttt{format}-muuttujan arvon \texttt{h}-helperin läpi. Se on \eng{alias}
\texttt{html\_escape}-helperille, joka \emph{pakenee} epäturvalliset
merkkijonot.

\begin{myfigure}[H]
\begin{pygmented}{diff}
--- a/app/helpers/application_helper.rb
+++ b/app/helpers/application_helper.rb
@@ -1,6 +1,6 @@
 module ApplicationHelper
   def timestamp time, format='%F %T'
-    content_tag :abbr, time.strftime(format),
+    content_tag :abbr, time.strftime(h(format)),
                 :class => 'timestamp', :title => time.iso8601
   end
 end
\end{pygmented}
\end{myfigure}
\end{samepage}

Nyt yksikään yksikkötesti ei epäonnistu, joten metodi toimii speksimme
mukaisesti.

\begin{samepage}
Nyt myös integraatiotestit onnistuvat, joten sovelluksemme toimii speksin
mukaisesti.

\begin{pygmented}{console}
% rake cucumber:wip
...
6 scenarios (6 passed)
43 steps (43 passed)
0m1.079s
\end{pygmented}
\end{samepage}

\begin{samepage}
Tee muutoksista commit.

\begin{pygmented}{console}
% git add .
% git commit -m 'Add timestamp to views'
\end{pygmented}
\end{samepage}

\begin{samepage}
Poista myös @wip-tagi \texttt{Manage Projects} -speksistä.

\begin{myfigure}[H]
\begin{pygmented}{diff}
--- a/features/manage_projects.feature
+++ b/features/manage_projects.feature
@@ -1,4 +1,3 @@
-@wip
 Feature: Manage projects
   In order to manage projects
   As a user
\end{pygmented}
\end{myfigure}

\begin{pygmented}{console}
% git commit -a -m 'manage_projects.feature: No longer @wip'
\end{pygmented}
\end{samepage}

Voit jälleen kokeilla sovellusta ajamalla komennon \texttt{script/rails server}
ja avaamalla web-sivun \url{http://0.0.0.0/projects}.

\subsubsection{Suhteelliset aikaleimat web-sivulle}

Otamme käyttöön timeago-pluginin\footnote{\url{http://timeago.yarp.com/}}, joka
muuttaa web-sivulla näkyvät aikaleimat muotoon ''\eng{less than a minute
ago}'', ''\eng{5 days ago}'' jne.

\begin{samepage}
Imuroi ensin plugin \texttt{public/javascripts}-hakemistoon.

\begin{pygmented}{console}
% wget -O public/javascripts/jquery.timeago.js \
> http://timeago.yarp.com/jquery.timeago.js
\end{pygmented}
\end{samepage}

\begin{samepage}
Luo \texttt{application.js} \myref{kuvan}{fig:application-js-00} mukaisesti.

\begin{myfigure}[H]
\caption{\texttt{public/javascripts/application.js}}
\label{fig:application-js-00}

\begin{pygmented}{javascript}
(function ($) {
  // Make timestamps relative.
  $(function () {
    $('abbr.timestamp').timeago ();
  });
}) (jQuery);
\end{pygmented}
\end{myfigure}
\end{samepage}

\begin{samepage}
Muokkaa \texttt{application}-layoutia.

\begin{myfigure}[H]
\begin{pygmented}{diff}
--- a/app/views/layouts/application.html.erb
+++ b/app/views/layouts/application.html.erb
@@ -3,7 +3,10 @@
 <head>
   <title><%= controller.action_name %> &ndash; <%= controller.controller_name %> &ndash; 5w</title>
   <%= javascript_include_tag 'http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js' %>
-  <%= javascript_include_tag 'rails', :cache => true %>
+  <%= javascript_include_tag 'rails',
+                             'jquery.timeago',
+                             'application',
+                             :cache => true %>
   <%= csrf_meta_tag %>
 </head>
 <body>
\end{pygmented}
\end{myfigure}
\end{samepage}

\begin{samepage}
Tee muutoksista commit.

\begin{pygmented}{console}
% git add .
% git commit -m 'Make timestamps relative using timeago'
\end{pygmented}
\end{samepage}

Voit jälleen kokeilla sovellusta ajamalla komennon \texttt{script/rails server}
ja avaamalla web-sivun \url{http://0.0.0.0/projects}.

\end{document}

% vim:set et sw=2 sts=2:
