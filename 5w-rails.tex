\documentclass{article}
\usepackage[english,finnish]{babel}
\usepackage[utf8]{inputenc}

\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[colorlinks=true]{hyperref}
\usepackage{xcolor}

\usepackage{texments}
\usestyle{default}

\renewcommand{\familydefault}{\sfdefault}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}

\newsavebox{\myfigurebox}
\newenvironment{myfigure}{
  \begin{figure}
    \centering
    \begin{lrbox}{\myfigurebox}
      \begin{minipage}{0.8\textwidth}
}{
      \end{minipage}
    \end{lrbox}
    \fcolorbox{blue}{blue!1}{\usebox{\myfigurebox}}
  \end{figure}
}

\newcommand{\en}[1]{\foreignlanguage{english}{#1}}

\title{\en{5w Ruby on Rails workshop}}
\author{Johan Kiviniemi}

\begin{document}
\maketitle

\begin{abstract}
Jotain dokumentaationtynkää 5w:n\footnote{\url{http://5w.fi/}}, Tampereen
hackerspacen, Rails-opiskeluprojektista.
\end{abstract}

\tableofcontents

\section{Sessio 2010-03-01}

\subsection{Railsin asentaminen}

\begin{samepage}
Tarkoituksena on käyttää Railsin
versiota~3\footnote{\url{http://guides.rails.info/3\_0\_release\_notes.html}},
joka on vielä beta-vaiheessa.

Asenna ensin Ruby~1.9.1 järjestelmään. Debianissa ja Ubuntussa tarvittavat
paketit tulevat ri1.9.1-paketin riippuvuuksina.

\begin{pygmented}{sh}
sudo apt-get install ri1.9.1
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna uusin RubyGems-versio omaan kotihakemistoosi. Kirjoitushetkellä
Debianissa ja Ubuntussa oleva RubyGems-versio on liian vanha.

\begin{pygmented}{sh}
mkdir -p /tmp/src/rubygems
cd /tmp/src/rubygems

# http://rubygems.org/pages/download
wget http://production.cf.rubygems.org/rubygems/rubygems-1.3.6.tgz

tar zxf rubygems-1.3.6.tgz
cd rubygems-1.3.6

export GEM_HOME="$HOME/.gem/ruby/1.9.1"
export PATH="$PATH:$GEM_HOME/bin:$HOME/.gem/rubygems/bin"
export RUBYLIB="$HOME/.gem/rubygems/lib"

ruby1.9.1 setup.rb --prefix="$HOME/.gem/rubygems"
\end{pygmented}
\end{samepage}

Lisää myös nuo kolme export-riviä shellisi käynnistystiedostoon (esim.
\textasciitilde/.bashrc tai \textasciitilde/.zshrc), jotta RubyGems-asennus
toimii jatkossakin käynnistämissäsi shelleissä.

\begin{samepage}
Seuraavaksi asenna Rails~3.

\begin{pygmented}{sh}
sudo apt-get install ruby1.9.1-dev libsqlite3-dev libopenssl-ruby1.9.1
gem1.9.1 install rails --pre
\end{pygmented}
\end{samepage}

\subsection{Uuden projektin luominen}

\begin{samepage}
Seuraavat komennot luovat \textasciitilde/src-hakemiston alle
t5w.fi-hakemiston, joka sisältää tyhjän Rails-projektin puun.

Tulemme käyttämään RSpec-kirjastoa yksikkötestaukseen TestUnitin sijaan, ja
jQuery-JavaScript-kirjastoa Prototypen sijaan. Lisää niistä myöhemmin.

\begin{pygmented}{sh}
cd ~/src
rails t5w.fi --skip-testunit --skip-prototype
cd t5w.fi
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna Gemfile-tiedoston listaamat projektin riippuvuudet.

\begin{pygmented}{sh}
bundle install
\end{pygmented}
\end{samepage}

Luomassamme projektissa on tiedosto \en{config/database.yml}, joka sisältää
asetukset tietokantaan yhdistämiseen. Emme halua sen päätyvän
versionhallintaan, koska tietokanta-asetukset tulevat olemaan mm.
kehitysympäristössä erilaiset kuin tuotantopalvelimella.

\begin{samepage}
Kopioi \en{config/database.yml} tiedostoon \en{config/database.yml.example}, ja
varmista, että vain jälkimmäinen päätyy versionhallintaan.

\begin{pygmented}{sh}
cp config/database.yml{,.example}
echo config/database.yml >>.gitignore
\end{pygmented}
\end{samepage}

Rails ylläpitää tiedostossa db/schema.rb kuvausta tietokannan skeemasta.
Sovelluksen päivityksen yhteydessä Railsin migrations-toiminto hoitaa olemassa
olevan tietokannan päivittämisen uuden koodin kanssa yhteensopivaksi, mutta
uudet tietokannat alustetaan suoraan kyseisen tiedoston perusteella.

\begin{samepage}
Jotta db/schema.rb:n lisääminen versionhallintaan ei pääse myöhemmin
unohtumaan, luodaan sen ensimmäinen (tyhjä) versio heti seuraavaa committia
varten Rake-komennolla {\tt db:migrate}.

\begin{pygmented}{sh}
rake db:migrate
\end{pygmented}
\end{samepage}

\subsection{Versionhallinnan alustaminen}

Jos olet käyttämässä Git-versionhallintaa ensimmäistä kertaa, katso
\hyperref[fig:git-initial-config]{kuva~\ref*{fig:git-initial-config}}.

\begin{myfigure}
\begin{pygmented}{sh}
git config --global user.name 'Etunimi Sukunimi'
git config --global user.email 'user@example.net'
for n in branch diff grep interactive status ui; do
  git config --global "color.$n" auto
done
\end{pygmented}
\caption{Perusasetuksien teko ensimmäisellä Git-käyttökerralla}
\label{fig:git-initial-config}
\end{myfigure}

\begin{samepage}
Alusta Git nykyiseen hakemistoon, lisää sisältö seuraavaa committia varten ja
luo ensimmäinen commit.

\begin{pygmented}{sh}
git init
git add .
git commit -m 'Initial import'
\end{pygmented}
\end{samepage}

\subsection{Testaus}

Testaaminen on oleellinen osa sovelluskehitystä. Jos jättäisimme testaamisen
väliin, meillä ei olisi mitään takeita siitä, että kukin tuotantoon asentamamme
ohjelmapäivitys toimii täysin oikein.

Pieniä ja isompia bugeja livahtaa koodiin aina, ja hyvin tehty testisarja
(engl. \en{test suite}) löytää ne nopeasti.

Käytän tässä dokumentissa termiä integraatiotestaus (engl. \en{integration
testing}) sovelluksen käyttäjälle näkyvän toiminnallisuuden kokonaisvaltaisesta
testaamisesta, ja termiä yksikkötestaus (engl. \en{unit testing}) sovelluksen
sisäisten rajapintojen testaamisesta.

Testit on mahdollista kirjoittaa ennen tai jälkeen varsinaisen toteutuksen
ohjelmoimista. Testien kirjoittamisesta etukäteen on joitakin
etuja\footnote{\en{Test Driven Development; Behavior Driven Development;
\url{http://en.wikipedia.org/wiki/Test-driven\_development##Benefits}}}:

\begin{itemize}
\item
Testisarjasta saadaan varmemmin kattava, mikäli pitäydytään toimintatavassa,
jossa ei kirjoiteta implementaatiokoodia ennen testien olemassaoloa.

\item
Tämä toimintatapa toimii apuvälineenä tulevan toteutuksen rajapinnan tai
käyttöliittymän suunnittelussa. Testejä luodessa kirjoitetaan koodia, joka
käyttää kuvitteellista, mahdollisimman miellyttävää rajapintaa.

Toteutusta tehdessä optimaalinen rajapinta tai käyttöliittymän toimintatapa on
näin jo hahmottunut.

\item
Hyvin tehdyt testit toimivat käytännön esimerkkeinä rajapintojen käytöstä,
täydentäen dokumentaatiota.

\item
Testisarja kertoo kunkin speksatun asian suhteen, mistä aloittaa, mitä tehdä
seuraavaksi ja milloin speksi on implementoitu.
\end{itemize}

\subsection{Testauskirjastojen asennus}

Käytämme RSpec\footnote{\url{http://rspec.info/}}-kirjastoa yksikkötestaukseen
ja Cucumber\footnote{\url{http://cukes.info/}}-kirjastoa
integraatiotestaukseen.

\begin{samepage}
Avaa Gemfile-tiedosto editoriin ja lisää siihen seuraavat rivit:

\begin{pygmented}{ruby}
group :test do
  gem 'rspec', '>= 2.0.0.a'
  gem 'rspec-rails', '>= 2.0.0.a'
  gem 'webrat'
  # The slimmed down version of test-unit in Ruby 1.9.1 isn't enough for
  # Cucumber.
  gem 'test-unit'
  gem 'cucumber'
  gem 'cucumber-rails'
end
\end{pygmented}
\end{samepage}

\begin{samepage}
Aja seuraavat komennot, jotta kyseiset gemit asentuvat.

\begin{pygmented}{sh}
# webrat requires this
sudo apt-get install libxslt-dev

bundle install
\end{pygmented}
\end{samepage}

\begin{samepage}
Asenna RSpecin ja Cucumberin projektikohtaiset tiedostot, jotta testaus niillä
onnistuu jatkossa.

\begin{pygmented}{sh}
script/rails generate rspec:install
script/rails generate cucumber:skeleton

# config/database.yml was modified, update example
cp config/database.yml{,.example}

git add .
git commit -m 'Add RSpec and Cucumber'
\end{pygmented}
\end{samepage}

% Why doesn’t this work?
%\subsection{Ensimmäinen integraatiotesti: \en{Manage projects}}
\subsection{Ensimmäinen integraatiotesti: Manage projects}

Luo editorissa tiedosto \en{features/manage\_projects.feature}
(\hyperref[fig:manage-projects-feature]{kuva~\ref*{fig:manage-projects-feature}}).

\begin{myfigure}
\includecode{include/manage_projects-00.feature}
\caption{\en{features/manage\_projects.feature}}
\label{fig:manage-projects-feature}
\end{myfigure}

Esimerkin alussa oleva {\em @wip} ({\em ''\en{work in progress}''}) on tagi,
jonka perusteella voidaan rajata työn alla olevat speksit ajettavaksi kerralla.

\en{Feature}-lohko alussa noudattaa tiettyä
formaattia\footnote{\url{http://wiki.github.com/aslakhellesoy/cucumber/gherkin}},
mutta on pelkkää dokumentaatiota. Varsinaiset ajettavat testit ovat
\en{Scenario}-lohkoissa.

Ensimmäinen skenaario testaa projektin onnistuneen lisäyksen käyttäjän
näkökulmasta.

Seuraava skenaario (huom. {\em ''\en{Scenario {\bf Outline}}''}) suoritetaan
sen sisältämän \en{Examples}-taulukon mukaisesti neljä kertaa, täydentäen
kulmasulkeiden sisältämien kenttien tilalle arvot taulukosta. Kyseinen
skenaario varmistaa virheenkäsittelyn toiminnan jättäen kullakin kerralla yhden
kentistä tyhjäksi (täyttäen muut validilla arvolla {\em ''x''}).

Viimeinen skenaario on samankaltainen ensimmäisen kanssa, mutta se varmistaa,
että lisätty projekti ilmestyy myös projektilistaan.

Risuaidalla alkavat rivit ovat kommentteja: \en{Who}-kenttien testaus
toteutetaan myöhemmin, kun sovellukseen lisätään tuki käyttäjätunnuksille.

Cucumber-Railsin mukana tulee ohjelmakoodia, jonka perusteella \en{Cucumber}
tietää, mitä tehdä, kun speksissä lukee esim. {\em ''\en{When I press ...}''}
tai {\em ''\en{Then I should see ...}''}.

Tämän speksin ainoa testi, jonka toteuttavan koodin joudumme toteuttamaan itse,
on {\em ''\en{Then I should see a timestamp no older/newer than ...}''}. Se
demonstroidaan seuraavalla kerralla.

\begin{samepage}
Tee myös tästä muutoksesta commit.

\begin{pygmented}{sh}
git add features
git commit -m 'Add initial manage_projects feature'
\end{pygmented}
\end{samepage}

\end{document}

% vim:set et sw=2 sts=2:
